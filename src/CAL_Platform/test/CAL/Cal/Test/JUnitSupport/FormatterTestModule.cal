/*
 * Copyright (c) 2007 BUSINESS OBJECTS SOFTWARE LIMITED
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *
 *     * Neither the name of Business Objects nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * FormatterTestModule.cal
 * By: Magnus Byne
 */

// Note: the following comment is a CALDoc comment
/**
 * {@summary This is a test module that tests pretty printing. It includes some comments and some {@em CALDoc @} too. @}
 *
 * Business Objects - {@url http://www.businessobjects.com@}
 *
 * General PR-related requests and questions email: pr\@businessobjects.com
 *
 * {@url http://www.businessobjects.com@} ..more of this paragraph.
 *
 * {@link function = List.map@}
 *
 * {@code foo "{\@ \@ bar \@ \@\@ \@\@\@ \ \n \t \f \ \  {\@ \@}" @}
 *
 * foo
 * {@code
 *    let
 *       f = 3.0;
 *    in
 *       f + f
 * @}
 *
 * {@orderedList
 *     {@item A
 *         {@code
 *    let
 *       f = 3.0;
 *    in
 *       f + f
 * @}
 *     @}
 *     {@item B more
 *         {@unorderedList
 *             {@item {@summary {@em (More of the summary) @}@} item B @}
 *         @}
 *     @}
 * @}
 *
 * foo bar baz
 *
 * qux
 *
 * @author Joseph Wong
 * @version no version yet
 * @author (other authors...)
 * @see module = Prelude, "Cal.IO.File", "Cal.Test.General.M1", Debug
 * @see function = List.map, "Cal.IO.File.makeFileName"
 * @see typeClass = Prelude.Eq, "Bounded"
 * @see typeConstructor = Maybe, "Cal.IO.File.FileName"
 * @see dataConstructor = Prelude.Left, "Cal.IO.File.FileName"
 */
module Cal.Test.JUnitSupport.FormatterTestModule;

import Cal.Core.Prelude using
    function =
        remainder, id, seq, error, add, upFromTo, upFromThen, upFromThenTo, or, not, and, equals, greaterThan, snd, compose, fst,
        upFrom, isEven, field3, compare, minBound, maxBound, max, min, input, output;
    typeConstructor = Byte, Float, Short, Int, Double, String, Boolean, Maybe, Ordering, Char, Long, JObject, JList, CalValue;
    dataConstructor = Cons, True, False, Nothing, Just, LT, EQ, GT, Left, Right;
    typeClass = Eq, Ord, Num, Bounded, Enum, Typeable;
    function = abs, toDouble, typeOf, unsafeCoerce, assert, eager;
    typeClass = Outputable, Inputable;
    typeConstructor = Integer, TypeRep;
    function = undefined, fromJust, isListType, isRecordType, isDoubleType, deepSeq;
    ;
import Cal.Utilities.Math using
    function = sin, cos, sqrt;
    ;

import Cal.Core.Char;
import Cal.Core.Dynamic using
    typeConstructor = Dynamic;
    function =
        appendRecord, appendDynamicRecord, insertRecordField, insertDynamicRecordField, recordFieldValue, dynamicRecordFieldValue;
    function = fromDynamic, dynamicRecordFieldValues, dynamicUnderlyingType, fromDynamicList, toDynamic;
    ;
import Cal.Collections.List using
    function =
        head, last, map, filter, replicate, sortBy, foldLeftStrict, foldRight, repeat, length, zip, isElemBy, drop, take,
        partition, foldLeft, sum, unzip3, groupBy, unzip, subscript, concatMap;
    function = inputList, outputList;
    ;
import Cal.Core.String using
    function = toList;
    ;
import Cal.Core.Debug using
    typeClass = Show;
    function = show, trace, showInternal, showInternalGraph, internalValueStats, setTracingEnabled;
    ;
import Cal.Test.Core.Debug_Tests;
import Cal.Test.General.M1;
import Cal.Test.General.Nofib;
import Cal.Test.General.GemScopeTestModule using
    function = regressionLine, regression, predictAt;
    ;
import Cal.Utilities.Decimal;
import Cal.Test.General.RecordTests;
import Cal.Test.General.LegacyTuple;
import Cal.Test.General.RuntimeRegression;
import Cal.Test.General.Shape_Tests;
import Cal.Test.General.InliningTests;
import Cal.Collections.Array using
    typeConstructor = Array;
    ;
import Cal.Test.Core.Prelude_Tests;
import Cal.Test.Core.String_Tests;
import Cal.Test.Collections.List_Tests;
import Cal.Test.Core.Array_Tests;
import Cal.Test.Core.Bits_Tests;
import Cal.Test.Core.Char_Tests;
import Cal.Test.Utilities.Decimal_Tests;
import Cal.Test.Utilities.QuickCheck_Tests;
import Cal.Test.Core.Dynamic_Tests;
import Cal.Test.Core.Memoize_Tests;
import Cal.Utilities.Random using
    function = randomInts;
    ;
import Cal.Test.Utilities.Random_Tests;
import Cal.Test.JUnitSupport.DerivedInstanceFunctionGenerator_Test_Support using
    function =
        testOrdInstanceWithValuesInAccendingOrder, testBoundedInstanceWithValuesInAccendingOrder,
        testEnumInstanceWithValuesInAccendingOrder;
    ;
import Cal.Test.Collections.IntMap_Tests;
import Cal.Test.Collections.LongMap_Tests;
import Cal.Test.Collections.Map_Tests;
import Cal.Test.Collections.Set_Tests;
import Cal.Test.Core.Monad_Tests;
import Cal.Test.Core.Functor_Tests;
import Cal.Test.Core.System_Tests;
import Cal.Test.Utilities.Locale_Tests;
import Cal.Test.Utilities.MessageFormat_Tests;
import Cal.Test.Core.Exception_Tests;
import Cal.Test.Core.Record_Tests;

/**
 * A test of "intra-word" formatting like Open{@strong Quark@}, or... Quark{@em Platform@}, or Super{@em Fun{@strong Fun@}Fun@}Stuff
 * - each of these should be one word!
 *
 * Note that in the above, the word Quark{@em Platform@} is intentionally positioned near the word-wrap boundary of 80 columns,
 * with the 'k' in Quark before the boundary, and the 'm' in {\@em beyond the boundary.
 */
public testIntraWordFormatting = Prelude.undefined;

/** Here we want to test that the caldoc wrapping is affected by how much the comment itself is indented */
x :: Int;
x =
    let
        /** Here we want to test that the caldoc wrapping is affected by how much the comment itself is indented */
        x =
            let
                x =
                    let
                        /**
                         * Here we want to test that the caldoc wrapping is affected by how much the comment itself is indented
                         *
                         * 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
                         */
                        x = (1 :: Int);

                        z =
                            if x == (1 :: Int) then
                                (
                                    let
                                        /**
                                         * Here we want to test that the caldoc wrapping is affected by how much the comment
                                         * itself is indented
                                         *
                                         * 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
                                         */
                                        y :: Int;
                                        y = (1 :: Int);
                                    in
                                        (1 :: Int)
                                )
                            else
                                (1 :: Int)
                            ;
                    in

                        x
                    ;
            in
                x
            ;
    in
        x
    ;

//this is code that wasn't formatted properly in 1.5.1 - the single line comment
//was misplaced by the formatter
/**
 * totalPrice is a CAL function taking two arguments, price and shipping. It calculates the totalPrice by multiplying the price
 * by the tax rate (in this example, 14%) and then adding the shipping costs.
 *
 * Of note in this example are that:
 * {@unorderedList
 *     {@item the formal parameters to the function are simply separated by spaces i.e. it is not written as totalPrice (price,
 *         shipping)
 *     @}
 *     {@item CAL follows the typical rules of operator precedence so that the multiplication is done first @}
 *     {@item the type of the totalPrice function is inferred by the CAL compiler @}
 * @}
 */
//totalPrice :: Double -> Double -> Double; //this type declaration is not
//necessary, the type is inferred
totalPrice price shipping = 1.14 * price + shipping;

//this had an extra space after "mixedRecord1 |" in 1.5.1
mixedRecord1 = {#1 = Just [10 :: Int, 20], #2 = False, name = "Anton", age = 1.0};

testMixed =
    assert
        (
            {mixedRecord1 | age := Just 3.5, favoriteFood = "chocolate"}
            == {name = "Anton", age = Just 3.5, #1 = Just [10 :: Int, 20], #2 = False, favoriteFood = "chocolate"}
        )
    ;

/** test extra parens are preserved */
paren_test1 :: () => a -> a;
paren_test1 a = a;

paren_test2 :: (Num a) => a -> a;
paren_test2 a = a;

paren_test3 :: Num a => (a -> a) -> (a -> a);
paren_test3 a = a;

class () => ParenClass1 a where
    parenClassTest1 :: a -> a;
    ;

class (Num a) => ParenClass2 a where
    parenClassTest2 :: a -> a;
    ;

paren_test4 y =
    case y of
    (True) -> True;
    ;

paren_test5 y =
    case y of
    True -> True;
    ;

paren_test6 = (1.0 + 2 + 4) + (((5 + (6))));

/** Test positions of plings in data constructors */
data public XXMap k a =
    private XXTip |
    private XXBin
        size :: !Int
        key :: !k
        value :: a
        leftMap :: !(XXMap k a)
        rightMap :: !(XXMap k a)
    ;

/**
 * {@unorderedList
 *     {@item Functions
 *         {@unorderedList
 *             {@item Checked qualified: {@link List.map@}@}
 *             {@item Checked unqualified: {@link id@}@}
 *             {@item Unchecked unqualified: {@link "id"@}@}
 *         @}
 *     @}
 *     {@item Data Constructors
 *         {@unorderedList
 *             {@item Checked qualified: {@link Prelude.Nothing@}@}
 *             {@item Checked unqualified: {@link Right@}@}
 *         @}
 *     @}
 *     {@item Type Constructors
 *         {@unorderedList
 *             {@item Checked qualified: {@link Prelude.Either@}@}
 *             {@item Checked unqualified: {@link Maybe@}@}
 *         @}
 *     @}
 *     {@item Type Classes
 *         {@unorderedList
 *             {@item Checked qualified: {@link Prelude.Outputable@}@}
 *             {@item Checked unqualified: {@link Bounded@}@}
 *         @}
 *     @}
 *     {@item Modules
 *         {@unorderedList
 *             {@item {@link Prelude@}@}
 *         @}
 *     @}
 * @}
 */
public testLinksWithoutContext = Prelude.undefined;

/**
 * This comment contains a number of \@see references, all without context!
 *
 * @see List.map, id, "id", Prelude.Nothing, Right, Prelude.Either, Maybe, Prelude.Outputable, Bounded, Prelude
 */
public testSeeWithoutContext = Prelude.undefined;

/**
 * {@em Emphasized {@strong then strong @} back to emphasized. @} {@strong Strong {@em then emphasized @} back to strong. @}
 *
 * {@strong log @} {@sub 2 @} 2 {@sup {@em n @}@} = {@em n @}
 */
public testFormattingInlineTags = Prelude.undefined;

/**
 * A test algebraic type.
 *
 * @author Joseph Wong
 * @see dataConstructor = XFoo
 * @see dataConstructor = Bar
 */
data public XFoo =
    /** No arg Foo. */
    public XFoo |
    /**
     * Bar has arghhhhs.
     * @arg alpha an integer
     * @arg beta a Foo
     * @arg #17 number seventeen!
     */
    public Bar
        //SL comment before field
        alpha :: Prelude.Int //SL comment after field
        beta :: XFoo //a blank line follows this comment

        #17 :: Prelude.Boolean
    deriving Prelude.Eq
    ;

/**
 * This is a copy of Prelude.apply.
 *
 * @arg func the function to apply.
 * @arg arg the argument to the application.
 * @return the result of the application of (func arg).
 * @deprecated You really should use Prelude.apply instead.
 *
 *   Don't use this function!
 * @author Joseph Wong
 *
 * @version the one and only version.
 * @see function = Prelude.apply
 */
//this is a comment between caldoc and func
appl :: (a -> b) -> a -> b;
/* */
/* **/
/* f*/
// these are all valid comments separating the definition from its type
//signature
public appl func = func;

//this comment is a not really associated to anything
//it is intended to have a blank line before and after it!

quadraticEquationSolver a b c =
    let
        disc = sqrt (b * b - 4 * a * c); //disc comment
    in
        ((-b + disc) / (2 * a), (-b - disc) / (2 * a)) //long exp
    ;

/** This data type has the constructors logically grouped using blank lines */
data public DbFunction =

    // Unary operators.
    public OpNot |
    public OpBitNot | //comment on OpBitNot line
    public OpNegate |
    public OpIsNull |
    public OpIsNotNull |
    public OpExists |

    // Binary operators
    public OpEq |
    public OpLt |
    public OpLtEq |
    public OpGt |
    public OpGtEq |
    public OpNotEq |
    public OpAnd |
    public OpOr |
    public OpLike |
    public OpIn |
    public OpCat |
    public OpPlus |
    public OpMinus |
    public OpMul |
    public OpDiv |
    public OpMod |
    public OpBitAnd |
    public OpBitOr |
    public OpBitXor |

    // Other operators
    public OpBetween |
    public OpCase_Simple |
    public OpCase_Searched |

    // Conversion functions
    public ConvertToStringFunction |
    public ConvertToIntFunction |
    public ConvertToDoubleFunction |
    public ConvertToTimeFunction |

    // Numeric functions
    public AbsFunction |
    public AcosFunction |
    public AsinFucntion |
    public AtanFunction |
    public Atan2Function |
    public CeilingFunction |
    public CosFunction |
    public CotFunction |
    public DegreesFunction |
    public ExpFunction |
    public FloorFunction |
    public LogFunction |
    public Log10Function |
    public ModFunction |
    public PiFunction |
    public PowerFunction |
    public RadiansFunction |
    public RandFunction |
    public RoundFunction |
    public SignFunction |
    public SinFunction |
    public SqrtFunction |
    public TanFunction |
    public TruncateFunction |

    // String functions
    public AsciiFunction |
    public CharFunction |
    public DifferenceFunction |
    public InsertFunction |
    public LcaseFunction |
    public LeftFunction |
    public LengthFunction |
    public LocateFunction |
    public LtrimFunction |
    public RepeatFunction |
    public ReplaceFunction |
    public RightFunction |
    public RtrimFunction |
    public SoundexFunction |
    public SpaceFunction |
    public SubstringFunction |
    public UcaseFunction |

    // System functions
    public DatabaseFunction |
    public UserFunction |

    // Null-handling functions
    public IfNullFunction |
    public NullIfFunction |

    // DateTime functions
    public DayNameFunction |
    public DayOfWeekFunction |
    public DayOfMonthFunction |
    public DayOfYearFunction |
    public HourFunction |
    public MinuteFunction |
    public MonthFunction |
    public MonthNameFunction |
    public NowFunction |
    public QuarterFunction |
    public SecondFunction |
    public WeekFunction |
    public YearFunction |
    public DateTimeAddFunction timeInterval :: Int |
    public DateTimeDiffFunction timeInterval :: Int |

    // Aggregation functions.
    public AggrCount |
    public AggrSum |
    public AggrAvg |
    public AggrMin |
    public AggrMax |
    public AggrDistinctCount |
    public AggrDistinctSum |
    public AggrDistinctAvg |
    public AggrCountAll |
    public AggrStdDev |
    public AggrStdDevP |
    public AggrVar |
    public AggrVarP |
    public AggrOther other :: String |

    // A function with the specified name.
    public FunctionOther funcName :: String
    ;

//function type test
fttest :: (a -> b) -> a -> b;
fttest f v = f v;

//comment before ones type dec
ones :: [Double];
ones = 1.0 : ones;

fibs :: [Int];
//test comment between fibs type and dec
fibs = 1 : 1 : List.zipWith Prelude.add fibs (List.tail fibs);

fib :: Int -> Int;
fib n = List.subscript fibs n;

test1 = Prelude.testPreludeModule;

test2 = Prelude.id 20.0 * Math.sqrt 9.0 == 60.0;

test3 = Prelude.id 20.0 * Math.sqrt 16.0 == 80.0;

test4 = M1.addThree 30.0 == 33;

test5 = M1.addThree 35.0 == 38; //comment on test5

test6 = List.length [('a', 10.0), ('b', 20.0), ('c', 30.0)] == 3;

test7 =
    List.length
        [
            't',
            'h',
            'i',
            's', //test comment after s in list
            ' ',
            'i',
            's',
            ' ',
            'a',
            //test comment on line before ' ' in list
            ' ',
            's',
            't',
            'r',
            'i',
            'n',
            'g'
        ]
        == 16
    && List.length [('a', 10.0), ('b', 20.0), ('c', 30.0)] == 3
    ;

testLambda4 = \x y z -> (\x y -> x + y) x z + (\y z -> 2 * y + z) (y + 3 * z) (x * y);

test8 =
    testLambda4 1.0 2 3 == 28.0
    && testLambda4 1.0 2 3 == 28.0
    && M1.testLambda4 1.0 2 3 == 28.0
    && M1.testLambda5 1.0 2 3 == 28.0
    ;

test9 = Prelude.equals (List.filter (\x0 -> Prelude.greaterThan x0 1.0) [2.0, 1.0, 3.0, 2.2, 3.3]) [2.0, 3.0, 2.2, 3.3];

runTargetTest10 x0 x1 = (\a b -> Prelude.multiply a b) x0 x1;

test10 = runTargetTest10 2.0 3.0 == 6.0;

testLet2 :: Int;
testLet2 =
    let
        mySum xs =
            case xs of
            [] -> 0;
            b : bs -> b + mySum bs;
            ;

        myProd xs =
            case xs of
            [] -> 1;
            b : bs -> b * myProd bs;
            ;

        oneToFour = List.take 4 (Prelude.upFrom 1);
    in
        mySum oneToFour + myProd oneToFour
    ;

test11 = testLet2 == 34;

test12 = 1.0 - 7 - 5 == 0 - 11;

test13 = -1.0 - -7 - 4 == 2;

foreign unsafe import jvm "static method java.lang.Math.min" private maxDoubleForeign :: Double -> Double -> Double;

foreign unsafe import jvm "static method java.lang.Math.min" private maxIntForeign :: Int -> Int -> Int;

test14 =
    maxDoubleForeign 2.0 4.0 == 2.0 && M1.maxDoubleForeign 2.0 4.0 == 4.0 && maxIntForeign 10 20 == 10
    || Prelude.error "MainM2.test14 failed."
    ;

test15 =
    2.0 + 3.0 == 5.0
        && Prelude.add 6.0 3.0 == 9.0
        && Prelude.add (10 :: Int) 20 == 30
        && List.sum (List.map (Prelude.add 10) [100, 200, 300]) == (630 :: Int)
        && List.filter (Prelude.greaterThanEquals 'b') ['d', 'd', 'c', 'c', 'a', 'd', 'b', 'c', 'c'] == ['a', 'b']
        && Prelude.equals ("foo" ++ "bar") "foobar"
        && Prelude.equals
            (Prelude.concat (List.map (Prelude.append ['z', 'a', 'p']) [['b', 'a', 'r'], ['f', 'o', 'o']]))
            ['z', 'a', 'p', 'b', 'a', 'r', 'z', 'a', 'p', 'f', 'o', 'o']
    || Prelude.error "MainM2.test15 (tests of functions with operator forms) failed."
    ;

test16Helper :: a -> Maybe a;
test16Helper x = Prelude.Just x;

test16 =
    (
        case test16Helper 'a' of
        Prelude.Just x -> x == 'a';
        Prelude.Nothing -> Prelude.False;
    )
    || Prelude.error "MainM2.test16 failed."
    ;

divide x = List.map Char.toUpperCase x;

test17 =
    Prelude.equals
        (divide
            (
                let
                    divide a b = Prelude.append a b;
                in
                    divide ['A', 'B'] ['a', 'b']
            )
        )
        ['A', 'B', 'A', 'B']
    || Prelude.error "FormatterTestModule.test17 failed."
    ;

test18 =
    Prelude.equals
        (divide
            (
                let
                    subtract a b = Prelude.append a b;
                in
                    subtract ['A', 'B'] ['a', 'b']
            )
        )
        ['A', 'B', 'A', 'B']
    || Prelude.error "FormatterTestModule.test17 failed."
    ;

unicodeCharactersInFile = "\u2153\u2154\u215b\u215c\u215d\u215e";

facAcc :: Prelude.Num a => a -> a -> a;
private facAcc a n =
    if n == 0 then
        a
    else
        facAcc (n * a) (n - 1)
    ;

factorial :: Prelude.Num a => a -> a;
factorial = facAcc 1;

test19 =
    Prelude.equals
        (Prelude.integerToString (factorial (Prelude.fromInt 50)))
        "30414093201713378043612608166064768844377641568960512000000000000"
    ;

test20 =
    Prelude.equals
        (Prelude.concat
            (List.map
                Prelude.integerToString
                (List.sort [Prelude.fromInt 100, Prelude.fromInt 2, Prelude.fromInt 4, Prelude.fromInt 232])
            )
        )
        "24100232"
    ;

class Musical a where
    toMusic :: a -> String;
    ;

instance Musical Int where
    toMusic = toMusicInt;
    ;

toMusicInt :: Int -> String;
toMusicInt i =
    if i == 0 then
        "A"
    else if i == 1 then
        "B flat"
    else
        "some other note"
    ;

test21 = Prelude.equals (toMusic (1 :: Int)) "B flat";

data private MyMaybe a =
    MyNothing |
    MyJust value :: a
    deriving Eq, Ord
    ;

testMyMaybeDerivedInstances =
    MyJust 'a' == MyJust 'a'
        && MyNothing == (MyNothing :: MyMaybe Int)
        && MyJust 'a' != MyJust 'b'
        && MyNothing != MyJust 2.0
        && [MyNothing, MyJust "abc"] == [MyNothing, MyJust "abc"]
        && MyNothing != MyJust (error "don\'t call this" :: String)
        && testOrdInstanceWithValuesInAccendingOrder [MyNothing, MyJust 'a', MyJust 'b']
    || error "FormatterTestModule.testMyMaybeDerivedInstances failed."
    ;

data private MyTuple2 a b =
    MyTuple2
        #1 :: a
        #2 :: b
    deriving Eq, Ord
    ;

testMyTuple2DerivedInstances =
    MyTuple2 "abc" True == MyTuple2 "abc" True
        && MyTuple2 2.0 "abc" != MyTuple2 2.0 "def"
        && MyTuple2 2.0 "abc" != MyTuple2 1.0 (error "don\'t call this")
        && MyTuple2 (MyJust 'a') Rameau == MyTuple2 (MyJust 'a') Rameau
        && MyTuple2 (MyJust 'a') Rameau != MyTuple2 (MyJust 'a') Bach
        && testOrdInstanceWithValuesInAccendingOrder
            [MyTuple2 0.0 "abc", MyTuple2 0.0 "def", MyTuple2 1.0 "abc", MyTuple2 1.0 "def", MyTuple2 2.0 ""]
    || error "FormatterTestModule.testMyTuple2DerivedInstances failed."
    ;

data MyComposersEnum =
    Bach |
    Rameau |
    Handel |
    Purcell |
    Dowland
    deriving Eq, Ord, Bounded, Enum
    ;

testMyComposersEnumDerivedInstances =
    List.group [Bach, Bach, Rameau, Handel, Purcell, Purcell, Dowland]
        == [[Bach, Bach], [Rameau], [Handel], [Purcell, Purcell], [Dowland]]
        && testOrdInstanceWithValuesInAccendingOrder [Bach, Rameau, Handel, Purcell, Dowland]
        && testBoundedInstanceWithValuesInAccendingOrder [Bach, Rameau, Handel, Purcell, Dowland]
        && testEnumInstanceWithValuesInAccendingOrder [Bach, Rameau, Handel, Purcell, Dowland]
    || error "FormatterTestModule.testMyComposersEnumDerivedInstances failed."
    ;

data private MyUnit =
    MyUnit
    deriving Eq, Ord, Bounded, Enum
    ;

testMyUnitDerivedInstances =
    testOrdInstanceWithValuesInAccendingOrder [MyUnit]
        && testBoundedInstanceWithValuesInAccendingOrder [MyUnit]
        && testEnumInstanceWithValuesInAccendingOrder [MyUnit]
    || error "FormatterTestModule.testMyUnitDerivedInstances failed."
    ;

data private MyBoolean =
    MyFalse |
    MyTrue
    deriving Eq, Ord, Bounded, Enum
    ;

testMyBooleanDerivedInstances =
    testOrdInstanceWithValuesInAccendingOrder [MyFalse, MyTrue]
        && testBoundedInstanceWithValuesInAccendingOrder [MyFalse, MyTrue]
        && testEnumInstanceWithValuesInAccendingOrder [MyFalse, MyTrue]
    || error "FormatterTestModule.testMyBooleanDerivedInstances failed."
    ;

data private MyWrap =
    MyWrap int :: Int
    deriving Eq, Ord
    ;

testMyWrapDerivedInstances =
    testOrdInstanceWithValuesInAccendingOrder [MyWrap 0, MyWrap 1, MyWrap 2]
    || error "FormatterTestModule.testMyWrapDerivedInstances failed."
    ;

data private MyOrdering =
    MyLT |
    MyEQ |
    MyGT
    deriving Eq, Ord, Bounded, Enum
    ;

testMyOrderingDerivedInstances =
    testOrdInstanceWithValuesInAccendingOrder [MyLT, MyEQ, MyGT]
        && testBoundedInstanceWithValuesInAccendingOrder [MyLT, MyEQ, MyGT]
        && testEnumInstanceWithValuesInAccendingOrder [MyLT, MyEQ, MyGT]
    || error "FormatterTestModule.testMyOrderingDerivedInstances failed."
    ;

data private MyBottomMiddleTop a =
    Bottom |
    Middle arg :: a |
    Top
    deriving Eq, Ord
    ;

testMyBottomMiddleTopDerivedInstances =
    testOrdInstanceWithValuesInAccendingOrder [Bottom, Middle 0.0, Middle 1.0, Middle 2.0, Top]
    || error "FormatterTestModule.testMyBottomMiddleTopDerivedInstances failed."
    ;

data private MyABCDEFG =
    MyA |
    MyB |
    MyC |
    MyD |
    MyE |
    MyF |
    MyG
    deriving Eq, Ord, Bounded, Enum
    ;

testMyABCDEFGDerivedInstances =
    testOrdInstanceWithValuesInAccendingOrder [MyA, MyB, MyC, MyD, MyE, MyF, MyG]
        && testBoundedInstanceWithValuesInAccendingOrder [MyA, MyB, MyC, MyD, MyE, MyF, MyG]
        && testEnumInstanceWithValuesInAccendingOrder [MyA, MyB, MyC, MyD, MyE, MyF, MyG]
    || error "FormatterTestModule.testMyABCDEFGDerivedInstances failed."
    ;

data private MyFooBarBaz a b =
    MyFoo arg :: a |
    MyBar |
    MyBaz arg :: b
    deriving Eq, Ord
    ;

testMyFooBarBazDerivedInstances =
    testOrdInstanceWithValuesInAccendingOrder [MyFoo 0.0, MyFoo 1.0, MyFoo 2.0, MyBar, MyBaz "abc", MyBaz "def", MyBaz "ghi"]
    || error "FormatterTestModule.testMyFooBarBazDerivedInstances failed."
    ;

data private MyList a =
    MyNil |
    MyCons
        arg1 :: a
        arg2 :: (MyList a)
    deriving Eq, Ord
    ;

testMyListDerivedInstances =
    let
        listToMyList lst =
            case lst of
            [] -> MyNil;
            x : xs -> MyCons x (listToMyList xs);
            ;
    in
        testOrdInstanceWithValuesInAccendingOrder
            [
                MyNil,
                listToMyList [1.0],
                listToMyList [1.0, 0.0],
                listToMyList [1.0, 0.0, 1.0],
                listToMyList [1.0, 1.0],
                listToMyList [2.0]
            ]
        || error "FormatterTestModule.testMyListDerivedInstances failed."
    ;

data private MyTuple3 a b c =
    MyTuple3
        #1 :: a
        #2 :: b
        #3 :: c
    deriving Eq, Ord
    ;

testMyTuple3DerivedInstances =
    testOrdInstanceWithValuesInAccendingOrder
        [
            MyTuple3 0.0 "abc" 0.0,
            MyTuple3 0.0 "abc" 1.0,
            MyTuple3 0.0 "def" 0.0,
            MyTuple3 1.0 "abc" 0.0,
            MyTuple3 1.0 "def" 0.0,
            MyTuple3 1.0 "def" 1.0,
            MyTuple3 2.0 "" 0.0
        ]
    || error "FormatterTestModule.testMyTuple3DerivedInstances failed."
    ;

data private MyTuple3B a b c =
    MyTuple3B
        #1 :: a
        field1 :: b
        field1_1 :: c
    deriving Eq, Ord, Inputable, Outputable, Debug.Show
    ;

testMyTuple3BDerivedInstances =
    testOrdInstanceWithValuesInAccendingOrder
        [
            MyTuple3B 0.0 "abc" 0.0,
            MyTuple3B 0.0 "abc" 1.0,
            MyTuple3B 0.0 "def" 0.0,
            MyTuple3B 1.0 "abc" 0.0,
            MyTuple3B 1.0 "def" 0.0,
            MyTuple3B 1.0 "def" 1.0,
            MyTuple3B 2.0 "" 0.0
        ]
    || error "FormatterTestModule.testMyTuple3BDerivedInstances failed."
    ;

data private MyT =
    MyT
    deriving Eq, Ord
    ;

data private EqualsMyT =
    EqualsMyT
    deriving Eq, Ord
    ;

testPreludeDerivedOrdInstances =
    testOrdInstanceWithValuesInAccendingOrder [[], [1.0], [1.0, 0.0], [1.0, 0.0, 1.0], [1.0, 1.0], [2.0]]
        && testOrdInstanceWithValuesInAccendingOrder [Nothing, Just 'a', Just 'b']
        && testOrdInstanceWithValuesInAccendingOrder [LT, EQ, GT]
        && testBoundedInstanceWithValuesInAccendingOrder [LT, EQ, GT]
        && testEnumInstanceWithValuesInAccendingOrder [LT, EQ, GT]
        && testOrdInstanceWithValuesInAccendingOrder [Left 'a', Left 'b', Right 'a', Right 'b']
        && testOrdInstanceWithValuesInAccendingOrder [False, True]
        && testBoundedInstanceWithValuesInAccendingOrder [False, True]
        && testOrdInstanceWithValuesInAccendingOrder [()]
        && testBoundedInstanceWithValuesInAccendingOrder [()]
    || error "FormatterTestModule.testPreludeDerivedOrdInstances failed."
    ;

data MyPhantomType1 a b =
    MyPhantom1 arg :: b
    deriving Eq
    ;

testMyPhantomType1DerivedInstances =
    (MyPhantom1 "abc" :: MyPhantomType1 Int String) == MyPhantom1 "abc"
        && (MyPhantom1 2.0 :: MyPhantomType1 Int Double) != MyPhantom1 1.0
    || error "FormatterTestModule.testMyPhantomType1DerivedInstances failed."
    ;

data MyPhantomType2 a =
    MyP1 |
    MyP2 |
    MyP3
    deriving Eq, Ord
    ;

testMyPhantomType2DerivedInstances =
    MyP1 == (MyP1 :: MyPhantomType2 [Int])
        && MyP2 == (MyP2 :: MyPhantomType2 String)
        && MyP3 == (MyP3 :: MyPhantomType2 (MyPhantomType1 Int Char))
        && MyP1 != (MyP2 :: MyPhantomType2 [MyComposersEnum])
        && not (MyP3 != (MyP3 :: MyPhantomType2 [MyComposersEnum]))
        && testOrdInstanceWithValuesInAccendingOrder [MyP1, MyP2, MyP3 :: MyPhantomType2 MyUnit]
    || error "FormatterTestModule.testMyPhantomType2DerivedInstances failed."
    ;

enumInstanceSpeedTest1 :: Int -> Ordering;
enumInstanceSpeedTest1 n = List.last (List.sort (List.take n (List.cycle [EQ, LT, GT])));

enumInstanceSpeedTest2 :: Int -> MedEnum;
enumInstanceSpeedTest2 n = List.last (List.sort (List.take n (List.cycle [MedEnum2, MedEnum1, MedEnum3])));

enumInstanceSpeedTest3 :: Int -> MyOrdering;
enumInstanceSpeedTest3 n = List.last (List.sort (List.take n (List.cycle [MyEQ, MyLT, MyGT])));

data BigEnum =
    BigEnum1 |
    BigEnum2 |
    BigEnum3 |
    BigEnum4 |
    BigEnum5 |
    BigEnum6 |
    BigEnum7 |
    BigEnum8 |
    BigEnum9 |
    BigEnum10 |
    BigEnum11 |
    BigEnum12 |
    BigEnum13 |
    BigEnum14 |
    BigEnum15 |
    BigEnum16 |
    BigEnum17 |
    BigEnum18 |
    BigEnum19 |
    BigEnum20 |
    BigEnum21 |
    BigEnum22 |
    BigEnum23 |
    BigEnum24 |
    BigEnum25 |
    BigEnum26 |
    BigEnum27 |
    BigEnum28 |
    BigEnum29 |
    BigEnum30 |
    BigEnum31 |
    BigEnum32 |
    BigEnum33 |
    BigEnum34 |
    BigEnum35 |
    BigEnum36 |
    BigEnum37 |
    BigEnum38 |
    BigEnum39 |
    BigEnum40 |
    BigEnum41 |
    BigEnum42 |
    BigEnum43 |
    BigEnum44 |
    BigEnum45 |
    BigEnum46 |
    BigEnum47 |
    BigEnum48 |
    BigEnum49 |
    BigEnum50 |
    BigEnum51 |
    BigEnum52 |
    BigEnum53 |
    BigEnum54 |
    BigEnum55 |
    BigEnum56 |
    BigEnum57 |
    BigEnum58 |
    BigEnum59 |
    BigEnum60 |
    BigEnum61 |
    BigEnum62 |
    BigEnum63 |
    BigEnum64 |
    BigEnum65 |
    BigEnum66 |
    BigEnum67 |
    BigEnum68 |
    BigEnum69 |
    BigEnum70 |
    BigEnum71 |
    BigEnum72 |
    BigEnum73 |
    BigEnum74 |
    BigEnum75 |
    BigEnum76 |
    BigEnum77 |
    BigEnum78 |
    BigEnum79 |
    BigEnum80 |
    BigEnum81 |
    BigEnum82 |
    BigEnum83 |
    BigEnum84 |
    BigEnum85 |
    BigEnum86 |
    BigEnum87 |
    BigEnum88 |
    BigEnum89 |
    BigEnum90 |
    BigEnum91 |
    BigEnum92 |
    BigEnum93 |
    BigEnum94 |
    BigEnum95 |
    BigEnum96 |
    BigEnum97 |
    BigEnum98 |
    BigEnum99 |
    BigEnum100
    deriving Eq, Ord, Bounded, Enum, Show
    ;

testBigEnumDerivedInstances =
    let
        list =
            [
                BigEnum1,
                BigEnum2,
                BigEnum3,
                BigEnum4,
                BigEnum5,
                BigEnum6,
                BigEnum7,
                BigEnum8,
                BigEnum9,
                BigEnum10,
                BigEnum11,
                BigEnum12,
                BigEnum13,
                BigEnum14,
                BigEnum15,
                BigEnum16,
                BigEnum17,
                BigEnum18,
                BigEnum19,
                BigEnum20,
                BigEnum21,
                BigEnum22,
                BigEnum23,
                BigEnum24,
                BigEnum25,
                BigEnum26,
                BigEnum27,
                BigEnum28,
                BigEnum29,
                BigEnum30,
                BigEnum31,
                BigEnum32,
                BigEnum33,
                BigEnum34,
                BigEnum35,
                BigEnum36,
                BigEnum37,
                BigEnum38,
                BigEnum39,
                BigEnum40,
                BigEnum41,
                BigEnum42,
                BigEnum43,
                BigEnum44,
                BigEnum45,
                BigEnum46,
                BigEnum47,
                BigEnum48,
                BigEnum49,
                BigEnum50,
                BigEnum51,
                BigEnum52,
                BigEnum53,
                BigEnum54,
                BigEnum55,
                BigEnum56,
                BigEnum57,
                BigEnum58,
                BigEnum59,
                BigEnum60,
                BigEnum61,
                BigEnum62,
                BigEnum63,
                BigEnum64,
                BigEnum65,
                BigEnum66,
                BigEnum67,
                BigEnum68,
                BigEnum69,
                BigEnum70,
                BigEnum71,
                BigEnum72,
                BigEnum73,
                BigEnum74,
                BigEnum75,
                BigEnum76,
                BigEnum77,
                BigEnum78,
                BigEnum79,
                BigEnum80,
                BigEnum81,
                BigEnum82,
                BigEnum83,
                BigEnum84,
                BigEnum85,
                BigEnum86,
                BigEnum87,
                BigEnum88,
                BigEnum89,
                BigEnum90,
                BigEnum91,
                BigEnum92,
                BigEnum93,
                BigEnum94,
                BigEnum95,
                BigEnum96,
                BigEnum97,
                BigEnum98,
                BigEnum99,
                BigEnum100
            ]
            ;
    in
        List.group [BigEnum1, BigEnum1, BigEnum5, BigEnum3, BigEnum3, BigEnum4, BigEnum2]
            == [[BigEnum1, BigEnum1], [BigEnum5], [BigEnum3, BigEnum3], [BigEnum4], [BigEnum2]]
            && testOrdInstanceWithValuesInAccendingOrder list
            && testBoundedInstanceWithValuesInAccendingOrder list
            && testEnumInstanceWithValuesInAccendingOrder list
        || error "FormatterTestModule.testBigEnumDerivedInstances failed."
    ;

data MedEnum =
    MedEnum1 |
    MedEnum2 |
    MedEnum3 |
    MedEnum4 |
    MedEnum5 |
    MedEnum6 |
    MedEnum7 |
    MedEnum8 |
    MedEnum9 |
    MedEnum10 |
    MedEnum11 |
    MedEnum12 |
    MedEnum13 |
    MedEnum14 |
    MedEnum15 |
    MedEnum16 |
    MedEnum17 |
    MedEnum18 |
    MedEnum19 |
    MedEnum20
    deriving Eq, Ord, Bounded, Enum, Show
    ;

testMedEnumDerivedInstances =
    let
        list =
            [
                MedEnum1,
                MedEnum2,
                MedEnum3,
                MedEnum4,
                MedEnum5,
                MedEnum6,
                MedEnum7,
                MedEnum8,
                MedEnum9,
                MedEnum10,
                MedEnum11,
                MedEnum12,
                MedEnum13,
                MedEnum14,
                MedEnum15,
                MedEnum16,
                MedEnum17,
                MedEnum18,
                MedEnum19,
                MedEnum20
            ]
            ;
    in
        List.group [MedEnum1, MedEnum1, MedEnum5, MedEnum3, MedEnum3, MedEnum4, MedEnum2]
            == [[MedEnum1, MedEnum1], [MedEnum5], [MedEnum3, MedEnum3], [MedEnum4], [MedEnum2]]
            && testOrdInstanceWithValuesInAccendingOrder list
            && testBoundedInstanceWithValuesInAccendingOrder list
            && testEnumInstanceWithValuesInAccendingOrder list
        || error "FormatterTestModule.testMedEnumDerivedInstances failed."
    ;

data foreign unsafe import jvm "int" MyInt deriving Outputable, Inputable;

data foreign unsafe import jvm "long" MyLong deriving Outputable, Inputable;

data foreign unsafe import jvm "char" MyChar deriving Outputable, Inputable;

data foreign unsafe import jvm "byte" MyByte deriving Outputable, Inputable;

data foreign unsafe import jvm "short" MyShort deriving Outputable, Inputable;

data foreign unsafe import jvm "float" MyFloat deriving Outputable, Inputable;

data foreign unsafe import jvm "double" MyDouble deriving Outputable, Inputable;

myIntToInt :: MyInt -> Int;
myIntToInt !x = unsafeCoerce x;

intToMyInt :: Int -> MyInt;
intToMyInt !x = unsafeCoerce x;

myLongToLong :: MyLong -> Long;
myLongToLong !x = unsafeCoerce x;

longToMyLong :: Long -> MyLong;
longToMyLong !x = unsafeCoerce x;

testOutThenInMyInt =
    myIntToInt (Prelude.input (Prelude.output (intToMyInt 100)) :: MyInt) == 100
    || error "FormatterTestModule.testOutThenInMyInt failed."
    ;

testOutThenInMyLong =
    myLongToLong (Prelude.input (Prelude.output (longToMyLong 200)) :: MyLong) == 200
    || error "FormatterTestModule.testOutThenInMyLong failed."
    ;

testOutThenIn3 = Prelude.input (Prelude.output (intToMyInt 300)) :: MyLong;

testOutThenIn4 = Prelude.input (Prelude.output (longToMyLong 400)) :: MyInt;

data foreign unsafe import jvm "java.lang.String" MyString deriving Inputable, Outputable;

data foreign unsafe import jvm "java.lang.StringBuilder" MyStringBuilder deriving Inputable, Outputable;

data foreign unsafe import jvm "java.lang.Object" MyObject deriving Inputable, Outputable;

testMyString = (Prelude.input (Prelude.output (Prelude.input (Prelude.output "abc") :: MyString)) :: String) == "abc";

testMyString2 = Prelude.output (Prelude.input (Prelude.output "abc") :: MyStringBuilder);

testComposeOpPrecedence =
    let
        l x = [x :: Int];

        isLHSApplicationGroupedBeforeComposeOp = typeOf (map id # l) == typeOf (map id # l);

        isComposeOpGroupedBeforeLHSApplication = typeOf (map id # l) == typeOf (map (id # l));

        a x = "a";

        b :: y -> Int -> String;
        b y z = "b";

        c = "c";

        isRHSApplicationGroupedBeforeComposeOp = typeOf (a # b c) == typeOf (a # b c);

        isComposeOpGroupedBeforeRHSApplication = typeOf (a # b c) == typeOf ((a # b) c);
    in
        isLHSApplicationGroupedBeforeComposeOp
            && not isComposeOpGroupedBeforeLHSApplication
            && isRHSApplicationGroupedBeforeComposeOp
            && not isComposeOpGroupedBeforeRHSApplication
        || error "FormatterTestModule.testComposeOpPrecedence failed."
    ;

testComposeOpSemantics =
    let
        a x = "a(" ++ show x ++ ")";

        b x = "b(" ++ show x ++ ")";

        c x = "c(" ++ show x ++ ")";
    in
        (a # b) 1.0 == a (b 1.0) && (a # b # c) 1.0 == a (b (c 1.0))
        || error "FormatterTestModule.testComposeOpSemantics failed."
    ;

testApplyOpAssociativity =
    let
        f :: a -> Int -> (Int, a);
        f a b = (b, a);

        g :: Int -> Int -> Int;
        g x y = x - y;

        isLeftAssociative = typeOf (f $ g 1 $ 2) == typeOf ((f $ g 1) $ 2);

        isRightAssociative = typeOf (f $ g 1 $ 2) == typeOf (f $ g 1 $ 2);
    in
        isRightAssociative && not isLeftAssociative || error "FormatterTestModule.testApplyOpAssociativity failed."
    ;

testApplyOpPrecedence =
    let
        f x = True;

        g x = False;
    in
        (f $ "hello" :: Boolean) && not (g $ False || True) || error "FormatterTestModule.testApplyOpPrecedence failed."
    ;

testApplyOpSemantics =
    (Prelude.pair 1.0 $ Prelude.pair 2.0 3.0) == Prelude.pair 1.0 (Prelude.pair 2.0 3.0)
        && (Prelude.pair 1.0 $ Prelude.triple 2.0 3.0 $ Prelude.negate 4.0)
            == Prelude.pair 1.0 (Prelude.triple 2.0 3.0 (Prelude.negate 4.0))
    || error "FormatterTestModule.testApplyOpSemantics failed."
    ;

isNull2 :: [a] -> Boolean;
isNull2 xs =
    case xs of
    [] -> True;
    _ : _ -> Prelude.False;
    ;

nonMultiple :: Int -> Int -> Boolean;
private nonMultiple arg arg_1 = Prelude.remainder arg arg_1 != (0 :: Int);

isPrime :: Int -> Boolean;
isPrime arg =
    let
        nToTest = arg;
    in
        List.andList
            (List.map
                (FormatterTestModule.nonMultiple nToTest)
                (Prelude.upFromTo (2 :: Int) (Prelude.round (Math.sqrt (Prelude.fromInt nToTest))))
            )
    ;

getNthPrime :: Int -> Int;
getNthPrime n =
    if n == 0 then
        2
    else if n < 0 then
        Prelude.error "getNthPrime: n must be >= 0."
    else
        List.subscript (List.filter FormatterTestModule.isPrime (Prelude.upFromThen (3 :: Int) (5 :: Int))) (n - 1)
    ;

nonMultiple2 :: Int -> Int -> Boolean;
private nonMultiple2 arg arg_1 = Prelude.remainder arg arg_1 != (0 :: Int);

isPrime2 :: Int -> Boolean;
isPrime2 nToTest =
    List.andList
        (List.map
            (FormatterTestModule.nonMultiple2 nToTest)
            (Prelude.upFromTo (2 :: Int) (Prelude.round (Math.sqrt (Prelude.toDouble nToTest))))
        )
    ;

getNthPrime2 :: Int -> Int;
getNthPrime2 n =
    if n == 0 then
        2
    else if n < 0 then
        Prelude.error "getNthPrime2: n must be >= 0."
    else
        List.subscript (List.filter FormatterTestModule.isPrime2 (Prelude.upFromThen (3 :: Int) (5 :: Int))) (n - 1)
    ;

nonMultiple3 :: Int -> Int -> Boolean;
private nonMultiple3 !arg !arg_1 = Prelude.remainder arg arg_1 != (0 :: Int);

isPrime3 :: Int -> Boolean;
isPrime3 !nToTest =
    List.andList
        (List.map
            (FormatterTestModule.nonMultiple3 nToTest)
            (Prelude.upFromTo (2 :: Int) (Prelude.round (Math.sqrt (Prelude.toDouble nToTest))))
        )
    ;

getNthPrime3 :: Int -> Int;
getNthPrime3 !n =
    if n == 0 then
        2
    else if n < 0 then
        Prelude.error "getNthPrime3: n must be >= 0."
    else
        List.subscript (List.filter FormatterTestModule.isPrime3 (Prelude.upFromThen (3 :: Int) (5 :: Int))) (n - 1)
    ;

private mapNonMultiple nToTest !list =
    case list of
    [] -> [];
    listHead : listTail -> (Prelude.remainder nToTest listHead != (0 :: Int)) : mapNonMultiple nToTest listTail;
    ;

isPrime4 :: Int -> Boolean;
isPrime4 !nToTest =
    List.andList
        (mapNonMultiple
            nToTest
            (Prelude.upFromTo (2 :: Int) (Prelude.round (Math.sqrt (Prelude.toDouble nToTest))))
        )
    ;

getNthPrime4 :: Int -> Int;
getNthPrime4 !n =
    if n == 0 then
        2
    else if n < 0 then
        Prelude.error "getNthPrime4: n must be >= 0."
    else
        List.subscript (List.filter FormatterTestModule.isPrime4 (Prelude.upFromThen (3 :: Int) (5 :: Int))) (n - 1)
    ;

private mapNonMultiple5 nToTest !list =
    case list of
    [] -> [];
    listHead : listTail -> nonMultiple5 nToTest listHead : mapNonMultiple5 nToTest listTail;
    ;

nonMultiple5 :: Int -> Int -> Boolean;
private nonMultiple5 !arg !arg_1 = Prelude.remainder arg arg_1 != (0 :: Int);

isPrime5 :: Int -> Boolean;
isPrime5 !nToTest =
    List.andList
        (mapNonMultiple5
            nToTest
            (Prelude.upFromTo (2 :: Int) (Prelude.round (Math.sqrt (Prelude.toDouble nToTest))))
        )
    ;

getNthPrime5 :: Int -> Int;
getNthPrime5 !n =
    if n == 0 then
        2
    else if n < 0 then
        Prelude.error "getNthPrime5: n must be >= 0."
    else
        List.subscript (List.filter FormatterTestModule.isPrime5 (Prelude.upFromThen (3 :: Int) (5 :: Int))) (n - 1)
    ;

andListMapNonMultiple6 nToTest !list =
    case list of
    [] -> True;
    listHead : listTail -> nonMultiple6 nToTest listHead && andListMapNonMultiple6 nToTest listTail;
    ;

nonMultiple6 :: Int -> Int -> Boolean;
private nonMultiple6 !arg !arg_1 = Prelude.remainder arg arg_1 != (0 :: Int);

isPrime6 :: Int -> Boolean;
isPrime6 !nToTest =
    andListMapNonMultiple6 nToTest (Prelude.upFromTo (2 :: Int) (Prelude.round (Math.sqrt (Prelude.toDouble nToTest))));

getNthPrime6 :: Int -> Int;
getNthPrime6 !n =
    if n == 0 then
        2
    else if n < 0 then
        Prelude.error "getNthPrime6: n must be >= 0."
    else
        List.subscript (List.filter FormatterTestModule.isPrime6 (Prelude.upFromThen (3 :: Int) (5 :: Int))) (n - 1)
    ;

andListMapNonMultipleUpFromTo7 :: Int -> Int -> Int -> Boolean;
andListMapNonMultipleUpFromTo7 nToTest !start !end =
    if start > end then
        True
    else
        let
            next = start + 1;
        in
            if next > end || next < start then
                nonMultiple7 nToTest start
            else
                nonMultiple7 nToTest start && andListMapNonMultipleUpFromTo7 nToTest next end
    ;

nonMultiple7 :: Int -> Int -> Boolean;
private nonMultiple7 !arg !arg_1 = Prelude.remainder arg arg_1 != (0 :: Int);

isPrime7 :: Int -> Boolean;
isPrime7 !nToTest =
    andListMapNonMultipleUpFromTo7 nToTest (2 :: Int) (Prelude.round (Math.sqrt (Prelude.toDouble nToTest)));

getNthPrime7 :: Int -> Int;
getNthPrime7 !n =
    if n == 0 then
        2
    else if n < 0 then
        Prelude.error "getNthPrime7: n must be >= 0."
    else
        List.subscript (List.filter FormatterTestModule.isPrime7 (Prelude.upFromThen (3 :: Int) (5 :: Int))) (n - 1)
    ;

filterUpFromByUpToInt8 :: (Int -> Boolean) -> Int -> Int -> Int -> [Int];
filterUpFromByUpToInt8 keepIfTrueFunction !start !step !end =
    if start > end then
        []
    else
        let
            next = start + step;
        in
            if next > end || next < start then
                if keepIfTrueFunction start then
                    start : []
                else
                    []
            else if keepIfTrueFunction start then
                start : filterUpFromByUpToInt8 keepIfTrueFunction next step end
            else
                filterUpFromByUpToInt8 keepIfTrueFunction next step end
    ;

andListMapNonMultipleUpFromTo8 :: Int -> Int -> Int -> Boolean;
andListMapNonMultipleUpFromTo8 nToTest !start !end =
    if start > end then
        True
    else
        let
            next = start + 1;
        in
            if next > end || next < start then
                nonMultiple8 nToTest start
            else
                nonMultiple8 nToTest start && andListMapNonMultipleUpFromTo8 nToTest next end
    ;

nonMultiple8 :: Int -> Int -> Boolean;
private nonMultiple8 !arg !arg_1 = Prelude.remainder arg arg_1 != (0 :: Int);

isPrime8 :: Int -> Boolean;
isPrime8 !nToTest =
    andListMapNonMultipleUpFromTo8 nToTest (2 :: Int) (Prelude.round (Math.sqrt (Prelude.toDouble nToTest)));

getNthPrime8 :: Int -> Int;
getNthPrime8 !n =
    if n == 0 then
        2
    else if n < 0 then
        Prelude.error "getNthPrime8: n must be >= 0."
    else
        List.subscript (filterUpFromByUpToInt8 FormatterTestModule.isPrime8 (3 :: Int) (2 :: Int) maxBound) (n - 1)
    ;

subscriptFilterUpFromByUpToInt9 :: (Int -> Boolean) -> Int -> Int -> Int -> Int -> Int;
subscriptFilterUpFromByUpToInt9 keepIfTrueFunction !start !step !end !index =
    if start > end then
        error "List.subscript: index out of bounds."
    else
        let
            next = start + step;
        in
            if next > end || next < start then
                if keepIfTrueFunction start then
                    if index == 0 then
                        start
                    else if index > 0 then
                        error "List.subscript: index out of bounds."
                    else
                        error "List.subscript: negative index."
                else
                    error "List.subscript: index out of bounds."
            else if keepIfTrueFunction start then
                if index == 0 then
                    start
                else if index > 0 then
                    subscriptFilterUpFromByUpToInt9 keepIfTrueFunction next step end (index - 1)
                else
                    error "List.subscript: negative index."
            else
                subscriptFilterUpFromByUpToInt9 keepIfTrueFunction next step end index
    ;

andListMapNonMultipleUpFromTo9 :: Int -> Int -> Int -> Boolean;
andListMapNonMultipleUpFromTo9 nToTest !start !end =
    if start > end then
        True
    else
        let
            next = start + 1;
        in
            if next > end || next < start then
                nonMultiple9 nToTest start
            else
                nonMultiple9 nToTest start && andListMapNonMultipleUpFromTo9 nToTest next end
    ;

nonMultiple9 :: Int -> Int -> Boolean;
private nonMultiple9 !arg !arg_1 = Prelude.remainder arg arg_1 != (0 :: Int);

isPrime9 :: Int -> Boolean;
isPrime9 !nToTest =
    andListMapNonMultipleUpFromTo9 nToTest (2 :: Int) (Prelude.round (Math.sqrt (Prelude.toDouble nToTest)));

getNthPrime9 :: Int -> Int;
getNthPrime9 !n =
    if n == 0 then
        2
    else if n < 0 then
        Prelude.error "getNthPrime9: n must be >= 0."
    else
        subscriptFilterUpFromByUpToInt9 FormatterTestModule.isPrime9 (3 :: Int) (2 :: Int) maxBound (n - 1)
    ;

getNthPrimeClean :: Int -> Int;
getNthPrimeClean n =
    let
        nonMultiple :: Int -> Int -> Boolean;
        nonMultiple x y = Prelude.remainder x y != 0;

        isPrime :: Int -> Boolean;
        isPrime nToTest =
            List.andList
                (List.map
                    (nonMultiple nToTest)
                    (Prelude.upFromTo 2 (Prelude.round (Math.sqrt (Prelude.fromInt nToTest))))
                )
            ;
    in
        if n == 0 then
            2
        else if n > 0 then
            List.subscript (List.filter isPrime (Prelude.upFromThen 3 5)) (n - 1)
        else
            Prelude.error "getNthPrime: n must be >= 0."
    ;

data Simpson =
    Bart |
    Homer |
    Lisa |
    Maggie |
    Marge
    ;

isBart :: Simpson -> Boolean;
isBart x =
    case x of
    Bart -> True;
    _ -> Prelude.False;
    ;

isSimpsonParent :: Simpson -> Boolean;
isSimpsonParent x =
    case x of
    Homer -> True;
    Marge -> True;
    _ -> Prelude.False;
    ;

test22 :: Boolean;
test22 =
    isBart Bart
        && Prelude.not (isBart Marge)
        && Prelude.not (isBart Homer)
        && Prelude.not (isBart Lisa)
        && Prelude.not (isBart Maggie)
        && isSimpsonParent Homer
        && isSimpsonParent Marge
        && Prelude.not (isSimpsonParent Bart)
        && Prelude.not (isSimpsonParent Lisa)
        && Prelude.not (isSimpsonParent Maggie)
    || Prelude.error "FormatterTestModule.test22 failed."
    ;

data NTuple a b c =
    OneTuple #1 :: a |
    TwoTuple
        #1 :: a
        #2 :: b |
    ThreeTuple
        #1 :: a
        #2 :: b
        #3 :: c
    ;

getThird :: NTuple a b c -> Maybe c;
getThird t =
    case t of
    ThreeTuple x y z -> Prelude.Just z;
    _ -> Prelude.Nothing;
    ;

test23 :: Boolean;
test23 =
    Prelude.isJust (getThird (ThreeTuple 'a' "ab" 2.0)) && Prelude.isNothing (getThird (TwoTuple "cd" 'c'))
    || Prelude.error "FormatterTestModule.test22 failed."
    ;

test24 :: Boolean;
test24 =
    (
        case ThreeTuple "abc" True 'z' of
        ThreeTuple _ _ v -> v == 'z';
    )
        &&
        (
            case ThreeTuple "abc" True 'z' of
            ThreeTuple t _ v -> v == 'z';
        )
        &&
        (
            case ThreeTuple "abc" True 'z' of
            ThreeTuple _ b _ -> b;
        )
        &&
        (
            case ThreeTuple "abc" True 'z' of
            ThreeTuple t b _ -> b;
        )
    || Prelude.error "FormatterTestModule.test24 failed."
    ;

test25 :: Boolean;
test25 =
    Prelude.equals (Prelude.Cons 'a' (Prelude.Cons 'b' (Prelude.Cons 'c' Prelude.Nil))) ['a', 'b', 'c']
        && Prelude.equals (Prelude.Cons 'd' (Prelude.Cons 'e' (Prelude.Cons 'f' []))) ['d', 'e', 'f']
        && Prelude.equals ('a', 2.0) (Prelude.tuple2 'a' 2.0)
        && Prelude.id
            (
                case ['a', 'b', 'c'] of
                Prelude.Cons x xs -> x;
            )
            == 'a'
        && Prelude.id
            (
                case [] of
                Prelude.Nil -> 'b';
            )
            == 'b'
        && Prelude.equals
            (Prelude.field2 (Prelude.tuple3 'a' ['f', 'o', 'o', 'B', 'a', 'r'] 2.0))
            ['f', 'o', 'o', 'B', 'a', 'r']
    || Prelude.error "FormatterTestModule.test25 failed."
    ;

test25_1 :: Prelude.List Double;
test25_1 = Prelude.Cons 1.0 (Prelude.Cons 2.0 Prelude.Nil);

test26 :: Boolean;
test26 =
    Char.toUpperCase
        (
            case ('b', True) of
            (x, y) -> x;
        )
        == 'B'
    || Prelude.error "FormatterTestModule.test26 failed."
    ;

zap4 :: Boolean;
zap4 = zap3 == 436 || Prelude.error "FormatterTestModule.zap4 failed";

zap3 :: Int;
zap3 = List.sum (List.map Char.toInt (Prelude.concat zap));

zap :: [[Prelude.Char]];
zap = List.map (zaptest 'r' Prelude.False 'b' True) ['x', 'y'];

zaptest :: Prelude.Char -> Boolean -> Prelude.Char -> Boolean -> Prelude.Char -> [Prelude.Char];
zaptest c1 b1 c2 b2 = zaplambdaLift c1 b1 c2 b2;

zaplambdaLift c1 b1 c2 b2 c3 = [zapeaselTest3 c3 c1 b1, zapeaselTest3 c3 c2 b2];

zapeaselTest3 :: Prelude.Char -> Prelude.Char -> Boolean -> Prelude.Char;
zapeaselTest3 c1 c2 b = Prelude.iff b 't' 'f';

lazyTest =
    lazyTest1
        && lazyTest2
        && lazyTest3
        && lazyTest4
        && lazyTest5
        && lazyTest6
        && lazyTest7 == 2.0
        && lazyTest9 10 10000 == Prelude.negate 1
        && lazyTest10 100 0 == 30
    || Prelude.error "FormatterTestModule.lazyTest failed."
    ;

lazyTest1 =
    List.length [(1 :: Int) / (0 :: Int), Prelude.error "FormatterTestModule.lazyTest1 failed"] == 2
    || Prelude.error "FormatterTestModule.lazyTest1 failed"
    ;

lazyTest2 =
    (
        case True of
        True -> True;
        Prelude.False -> Prelude.error "FormatterTestModule.lazyTest2 failed.";
    )
    || Prelude.error "FormatterTestModule.lazyTest2 failed."
    ;

lazyTest3 =
    (
        let
            x =
                case ['a', 'b'] of
                u : us -> u;
                [] -> Prelude.error "FormatterTestModule.lazyTest3 failed.";
                ;
        in
            x == 'a'
    )
    || Prelude.error "FormatterTestModule.lazyTest3 failed."
    ;

lazyTest4 =
    (
        if Prelude.False then
            case Debug.trace "FormatterTestModule.lazyTest4 failed.\n" Prelude.Nothing of
            Prelude.Nothing -> Prelude.False;
        else
            True
    )
    || Prelude.error "FormatterTestModule.lazyTest4 failed."
    ;

errorIfWinter s =
    case s of
    M1.Winter -> Prelude.error "error, Winter selected";
    _ -> True;
    ;

lazyTest5 =
    Prelude.iff Prelude.False (errorIfWinter M1.Winter) (errorIfWinter M1.Summer)
    || Prelude.error "FormatterTestModule.lazyTest5 failed."
    ;

lazyTest6 =
    Prelude.iff
        Prelude.False
        (
            case Debug.trace "FormatterTestModule.lazyTest6 failed.\n" True of
            True -> Prelude.False;
        )
        True
    || Prelude.error "FormatterTestModule.lazyTest6 failed."
    ;

lazyTest7 =
    let
        x =
            case y of
            True -> 1.0;
            Prelude.False -> 0.0;
            ;

        y = 1.0 > 0.0;
    in
        2.0
    ;

lazyTest8 :: Int -> Int -> Int;
lazyTest8 n m =
    if n == 0 then
        case List.reverse (List.take m M1.allPrimes) of
        b : bs -> b;
        [] -> Prelude.negate 1;
    else
        Prelude.negate 1
    ;

lazyTest9 :: Int -> Int -> Int;
lazyTest9 n m =
    Prelude.iff
        (n == 0)
        (
            (
                case List.reverse (List.take m M1.allPrimes) of
                b : bs -> b;
                [] -> Prelude.negate 1;
            )
            + 100
        )
        (Prelude.negate 1)
    ;

lazyTest10 :: Int -> Int -> Int;
lazyTest10 n m =
    Prelude.iff
        (m != 0)
        (
            case n / m == 5 of
            True -> 10 + n;
            Prelude.False -> 20 + n;
        )
        30
    ;

foo1 =
    Prelude.iff
        Prelude.False
        (
            case Prelude.error "FormatterTestModule.foo1 failed." of
            True -> 40.0;
        )
        20.0
    ;

foo2 =
    Prelude.iff
        Prelude.False
        (
            let
                x =
                    case Prelude.error "FormatterTestModule.foo2 failed." of
                    True -> 40.0;
                    ;
            in
                x
        )
        20.0
    ;

foo3 =
    Prelude.iff
        Prelude.False
        (
            (
                \x ->
                    case Prelude.error "FormatterTestModule.foo3 failed." of
                    True -> 40.0;
            )
                ()
        )
        20.0
    ;

liftedCase =
    case Prelude.error "FormatterTestModule.foo4 failed." of
    True -> 40.0;
    ;

foo4 = Prelude.iff Prelude.False liftedCase 20.0;

foo5 =
    Prelude.iff
        Prelude.False
        (
            if True then
                case Prelude.error "FormatterTestModule.foo5 failed." of
                True -> 40.0;
            else
                Prelude.error "no!"
        )
        20.0
    ;

foo6 =
    Prelude.iff
        Prelude.False
        (
            case
                let
                    e = Prelude.error "FormatterTestModule.foo6 failed.";
                in
                    e
            of
            True -> 40.0;
        )
        20.0
    ;

foo7 =
    Prelude.iff
        Prelude.False
        (
            let
                x = Prelude.error "M2.foo7 failed.";
            in
                x
        )
        20.0
    ;

let1 =
    (
        let
            a = List.map;
        in
            a
    )
        Prelude.isEmpty
    ;

letTest1 = let1 [['a'], [], ['b']] == [Prelude.False, True, Prelude.False];

ciTest1 :: Boolean;
ciTest1 =
    (1.0, 'a') == (1.0, 'a')
    && ([1.0, 2.0], ("abc", 5 :: Int)) == ([1.0, 2.0], ("abc", 5 :: Int))
    && List.take 5 M1.allPrimes == [2, 3, 5, 7, 11]
    &&
    [
        [[[['a']]]]
    ]
        ==
        [
            [[[['a']]]]
        ]
    &&
    [
        [[[['a']]]]
    ]
        <=
        [
            [[[['a']]]]
        ]
    && List.map (Prelude.equals []) [[], [1.0]] == [True, Prelude.False]
    && [(1.0, 'a'), (2.0, 'b')] == [(1.0, 'a'), (2.0, 'b')]
    && ((('a', 1.0), True), 5 :: Int) == ((('a', 1.0), True), 5 :: Int)
    && List.sort [('z', 2.0), ('a', 3.0)] == List.reverse [('z', 2.0), ('a', 3.0)]
    ;

ciTest2Helper :: Double -> Boolean;
ciTest2Helper x = (1.0, 'a') == (x, 'a');

ciTest2 = ciTest2Helper 1.0 && Prelude.not (ciTest2Helper 2.0);

ciTest3Helper ::
    (Prelude.Eq a, Prelude.Ord b, Prelude.Appendable c) =>
    a -> b -> c -> [a] -> [b] -> c -> (Boolean, (Boolean, c));
ciTest3Helper x y z xs ys zs = (xs == [x], ([y] < ys, z ++ zs));

ciTest3 =
    ciTest3Helper 2.0 (5 :: Int) "abc" [2.0] [4 :: Int] "def" == (True, (Prelude.False, "abcdef"))
    && ciTest3Helper (2.0, 'a') [4, 5] "a" [(2.0, 'a')] [[4 :: Int, 6]] "d" == (True, (True, "ad"))
    ;

ciTest4 :: Prelude.Ord a => a -> a -> [a];
ciTest4 x y =
    if x > y then
        [x, y]
    else
        [y, x]
    ;

ciTest5 :: Prelude.Eq a => [a] -> [a] -> Boolean;
ciTest5 x y = True;

ciTest6Helper :: Prelude.Eq a => a -> a -> Boolean;
ciTest6Helper x y = Prelude.equals x y;

ciTest6 :: Prelude.Eq a => a -> a -> Boolean;
ciTest6 x y = ciTest6Helper [x] [y];

ciTest7 xs = List.sort xs == xs;

class Music a where
    playMusic :: a -> [Prelude.Char];
    ;

instance Music (Maybe a) where
    playMusic = maybePlayMusic;
    ;

maybePlayMusic :: Maybe a -> [Prelude.Char];
maybePlayMusic y =
    case y of
    Prelude.Just x -> toList "tra la la - Just picked";
    Prelude.Nothing -> toList "tra la la - Nothing picked";
    ;

class Person a where
    name :: a -> String;
    ;

class Person a => Programmer a where
    nComputers :: a -> Int;
    ;

nameMaybe :: Maybe a -> String;
nameMaybe x = "the function nameMaybe";

nComputersMaybe :: Maybe a -> Int;
nComputersMaybe x = 10;

music1 = playMusic (Prelude.Just 'a');

music2 = playMusic (Prelude.Just 'b');

class Appendable a where
    ap :: a -> a -> a;
    ;

appendString :: String -> String -> String;
appendString = Prelude.append;

instance Appendable String where
    ap = appendString;
    ;

instance Appendable (Prelude.List a) where
    ap = appendList;
    ;

appendList :: [a] -> [a] -> [a];
appendList = Prelude.append;

testAp1 x = ap x x;

testAp2 y = ap (List.head y : y) y;

applyPointwise :: [a -> b] -> [a] -> [b];
private applyPointwise fs xs =
    case fs of
    fs_head : fs_tail ->
        case xs of
        xs_head : xs_tail -> fs_head xs_head : applyPointwise fs_tail xs_tail;
        [] -> [];
        ;
    [] -> [];
    ;

succ :: ([b] -> c) -> [a -> b] -> [a] -> c;
private succ n fs bs = n (applyPointwise fs bs);

zero :: [a] -> [a];
zero x = x;

one :: [a -> b] -> [a] -> [b];
one = succ zero;

two :: [a -> b -> c] -> [a] -> [b] -> [c];
two = succ one;

three :: [a -> b -> c -> d] -> [a] -> [b] -> [c] -> [d];
three = succ two;

four :: [a -> b -> c -> d -> e] -> [a] -> [b] -> [c] -> [d] -> [e];
four = succ three;

zipperWith :: ([a] -> b) -> a -> b;
zipperWith n f = n (List.repeat f);

private testZipperWith =
    zipperWith three Prelude.tuple3 (toList "abc") [1.0, 10.0, 100.0] [Prelude.LT, Prelude.GT, Prelude.EQ]
        == [('a', 1.0, Prelude.LT), ('b', 10.0, Prelude.GT), ('c', 100.0, Prelude.EQ)]
    || Prelude.error "testZipperWith failed."
    ;

data Feeling =
    Vaguely feeling :: Feeling |
    Mixed
        feeling1 :: Feeling
        feeling2 :: Feeling |
    Love object :: String |
    Hate object :: String |
    Happy |
    Depressed
    ;

feelingValue = Vaguely (Mixed (Love "pleasure") (Hate "pain"));

feelingEntry x = Prelude.asTypeOf x feelingValue;

data Feeling2 a b =
    Vaguely2 feeling :: (Feeling2 a b) |
    Mixed2
        feeling1 :: (Feeling2 a b)
        feeling2 :: (Feeling2 a b) |
    Love2 object :: a |
    Hate2 object :: b |
    Happy2 |
    Depressed2
    ;

feeling2Value = Mixed2 (Vaguely2 Happy2) (Love2 "wake up in the morning");

feeling2Entry x = Prelude.asTypeOf feeling2Value;

data Fruit =
    Orange |
    Apple |
    Pear |
    Cherry
    ;

fruitValue = Cherry;

fruitEntry x = Prelude.asTypeOf x fruitValue;

data Fruit2 =
    private Orange2 |
    private Apple2 |
    private Pear2 |
    private Cherry2
    ;

fruit2Value = Cherry2;

fruit2Entry x = Prelude.asTypeOf x fruit2Value;

data Fruit3 =
    Orange3 |
    Apple3 |
    private OtherFruit3 name :: String |
    Pear3 |
    Cherry3
    ;

fruit3Value = Cherry3;

fruit3Entry x = Prelude.asTypeOf x fruit3Value;

data Fruit4 a =
    private Orange4 |
    private Apple4 |
    private OtherFruit4 name :: a |
    private Pear4 |
    private Cherry4
    ;

fruit4Value = Cherry4;

fruit4Entry x = Prelude.asTypeOf x fruit4Value;

data Type1 =
    DataCons1
        arg1 :: Prelude.Char
        arg2 :: Int
        arg3 :: Boolean
    ;

type1Value = DataCons1 'a' 10 True;

type1Entry x = Prelude.asTypeOf x type1Value;

data Type2 =
    DataCons2
        arg1 :: [Prelude.Char]
        arg2 :: (Int, Double)
        arg3 :: (Maybe Prelude.Ordering)
    ;

type2Value = DataCons2 (toList "Hello module M2") (10, 20) (Prelude.Just Prelude.GT);

type2Entry x = Prelude.asTypeOf x type2Value;

data Type3 =
    DataCons3_1 arg1 :: Int |
    DataCons3_2 arg2 :: Prelude.Char |
    DataCons3_3 arg3 :: Boolean
    ;

type3Value = DataCons3_2 'a';

type3Entry x = Prelude.asTypeOf x type3Value;

data SimpleChain =
    SimpleChain restOfChain :: SimpleChain |
    EndChain
    ;

simpleChainValue = SimpleChain (SimpleChain (SimpleChain EndChain));

simpleChainEntry x = Prelude.asTypeOf x simpleChainValue;

data OrdList =
    OrdCons
        head :: Prelude.Ordering
        tail :: OrdList |
    OrdNil
    ;

ordListValue = OrdCons Prelude.LT (OrdCons Prelude.EQ OrdNil);

ordListEntry x = Prelude.asTypeOf x ordListValue;

data Chain =
    Link rest :: Chain |
    End
    ;

data Chain2 =
    Link2 rest :: Chain2 |
    private End2
    ;

data Chain3 =
    Link3 rest :: Chain3 |
    Token3 special :: Special3
    ;

data Special3 =
    Special3 special :: Special3 |
    End3
    ;

data Chain4 =
    Link4 rest :: Chain4 |
    Token4 special :: Special4
    ;

data Special4 =
    Special4 special :: Special4 |
    private End4
    ;

data Chain5 =
    Link5 rest :: Chain5 |
    Token5 special :: Special5
    ;

data private Special5 =
    private Special5 special :: Special5 |
    private End5
    ;

data Chain6 =
    Link6 rest :: Chain6 |
    OtherLink6 more :: BigChain6 |
    Token6 special :: Special6
    ;

data Special6 =
    Special6 special :: Special6 |
    End6
    ;

data BigChain6 =
    BigLink6 rest :: BigChain6 |
    private BigEnd6
    ;

oldLast :: [a] -> a;
oldLast !xs =
    case xs of
    b : bs ->
        if Prelude.isEmpty bs then
            b
        else
            oldLast bs
        ;
    [] -> Prelude.error "M2.oldLast: empty list.";
    ;

oldLast2 :: [a] -> a;
oldLast2 xs =
    case xs of
    b : bs ->
        if isNull2 bs then
            b
        else
            oldLast2 bs
        ;
    [] -> Prelude.error "M2.oldLast2: empty list.";
    ;

newLast :: [a] -> a;
newLast !list =
    case list of
    list_head : list_tail ->
        let
            transfer :: a -> [a] -> a;
            transfer element !list =
                case list of
                [] -> element;
                list_head : list_tail -> transfer list_head list_tail;
                ;
        in
            transfer list_head list_tail
        ;
    [] -> Prelude.error "M2.newLast: empty list.";
    ;

newLast2 :: [a] -> a;
newLast2 !list =
    case list of
    list_head : list_tail -> transferForNewLast2 list_head list_tail;
    [] -> Prelude.error "M2.newLast: empty list.";
    ;

transferForNewLast2 :: a -> [a] -> a;
transferForNewLast2 element !list =
    case list of
    [] -> element;
    list_head : list_tail -> transferForNewLast2 list_head list_tail;
    ;

perfTestLast :: ([Prelude.Char] -> Prelude.Char) -> Prelude.Char;
perfTestLast lastFunction = lastFunction (List.replicate 3000000 'a');

oldReverse :: [a] -> [a];
oldReverse = List.foldLeft (Prelude.flip Prelude.Cons) [];

newReverse :: [a] -> [a];
newReverse !list =
    let
        transfer !sourceList resultList =
            case sourceList of
            [] -> resultList;
            headSourceList : tailSourceList -> transfer tailSourceList (headSourceList : resultList);
            ;
    in
        transfer list []
    ;

newReverse2 :: [a] -> [a];
newReverse2 !list = transferForNewReverse2 list [];

transferForNewReverse2 :: [a] -> [a] -> [a];
transferForNewReverse2 !sourceList resultList =
    case sourceList of
    [] -> resultList;
    headSourceList : tailSourceList -> transferForNewReverse2 tailSourceList (headSourceList : resultList);
    ;

perfTestReverse :: ([Int] -> [Int]) -> Int;
perfTestReverse reverseFunction = List.head (reverseFunction (Prelude.upFromTo 1 500000));

perfTest2Reverse :: ([Int] -> [Int]) -> Int;
perfTest2Reverse reverseFunction = List.last (reverseFunction (Prelude.upFromTo 1 500000));

testAlternativeImplementationsOfPreludeFunctions =
    newLast (Prelude.upFromTo (1 :: Int) (5 :: Int)) == oldLast (Prelude.upFromTo (1 :: Int) (5 :: Int))
    && newLast2 (toList "abcdefg") == oldLast (toList "abcdefg")
    && newReverse (Prelude.upFromTo (1 :: Int) (8 :: Int)) == oldReverse (Prelude.upFromTo (1 :: Int) (8 :: Int))
    && newReverse2 (toList "foo bar") == oldReverse (toList "foo bar")
    ;

ack :: Int -> Int -> Int;
ack m n =
    if m == 0 then
        n + 1
    else if n == 0 then
        ack (m - 1) 1
    else
        ack (m - 1) (ack m (n - 1))
    ;

randloop :: Int -> Int -> Double -> Double -> Double;
randloop n seed r max =
    if n == 0 then
        r
    else
        let
            normalize x max = Prelude.fromInt x * (max / imd);

            newseed = Prelude.remainder (seed * ia + ic) im;

            newrand = normalize newseed max;

            im = 139968;

            imd = Prelude.fromInt im;

            ia = 3877;

            ic = 29573;
        in
            randloop (n - 1) newseed newrand max
    ;

randTest = randloop 1000 42 0 1000;

testListOutput :: Int -> Prelude.JObject;
testListOutput n = Prelude.output (Prelude.upFromTo (1 :: Int) n);

tripleDataSource :: Int -> [(Int, Int, Int)];
tripleDataSource n =
    List.zip3 (Prelude.upFromTo (1 :: Int) n) (Prelude.upFromThen (1 :: Int) 3) (Prelude.upFromThen (1 :: Int) 4);

data RData =
    DC1 |
    DC2 |
    DC3 |
    DC4
    ;

testBooleanCaseStatements =
    rtest1 DC1 == True
        && rtest1 DC3 == Prelude.False
        && rtest1 DC4 == True
        && rtest2 DC1 == True
        && rtest2 DC3 == Prelude.False
        && rtest2 DC4 == Prelude.False
        && rtest3 DC2 == True
        && rtest4 DC2 == True
        && rtest4 DC1 == Prelude.False
        && rtest5 DC2 == Prelude.False
        && rtest5 DC1 == True
        && rtest8 DC2 == True
        && rtest9 DC2 == Prelude.False
    || Prelude.error "Failed M2.testBooleanCaseStatements"
    ;

rtest1 x =
    case x of
    DC1 -> True;
    DC2 -> True;
    DC3 -> Prelude.False;
    _ -> True;
    ;

rtest2 x =
    case x of
    DC1 -> True;
    DC2 -> True;
    DC3 -> Prelude.False;
    _ -> Prelude.False;
    ;

rtest3 x =
    case x of
    DC1 -> True;
    _ -> True;
    ;

rtest4 x =
    case x of
    DC1 -> Prelude.False;
    _ -> True;
    ;

rtest5 x =
    case x of
    DC1 -> True;
    _ -> Prelude.False;
    ;

rtest8 x =
    case x of
    DC1 -> True;
    DC2 -> True;
    ;

rtest9 x =
    case x of
    DC1 -> Prelude.False;
    DC2 -> Prelude.False;
    ;

charlie x =
    let
        wonka :: a -> a -> [a];
        wonka y z = [y, z];
    in
        (wonka 2.0 3.0, wonka x 'a')
    ;

charlie2 x =
    let
        wonka :: a -> Prelude.Maybe a -> [Prelude.Maybe a];
        wonka y z = [Prelude.Just y, z];

        willy :: Prelude.Maybe a -> a -> [Prelude.Maybe a];
        willy z y = [z, Prelude.Just y, z];
    in
        (wonka 2.0 (Prelude.Just 3.0), wonka x (Prelude.Just 'a'))
    ;

letVarTest =
    let
        a = b;

        c = d;

        e = f;

        b = c;

        d = e;

        f = 1.0;
    in
        a + b + c + d + e + f == 6.0
    ;

badgem x0 x1 x3 = List.take x0 (List.map (\x2 -> predictAt (regression x1) x2) (Prelude.upFrom x3));

badgem2 x1 x3 = List.map (\x2 -> predictAt (regression x1) x2) (Prelude.upFrom x3);

badgem3 x3 = List.map (\x2 -> predictAt (regression [1.0, 2.0]) x2) (Prelude.upFrom x3);

badgemtest = List.last (badgem 20 (regressionLine 20) 20.0) == 39.0;

data Foo a b c =
    Foo
        #1 :: !a
        #2 :: !b
        #3 :: !c
    ;

testFoo :: Int;
testFoo =
    case Foo (error "arg1") (error "arg2") (error "arg3") of
    Foo x y z -> error "after unpack";
    ;

data Foo2 a b c =
    Foo2
        #1 :: a
        #2 :: b
        #3 :: c
    ;

foo2Strict = \x y z -> seq x (seq y (seq z (Foo2 x) y) z);

testFoo2Strict :: Int;
testFoo2Strict =
    case foo2Strict (error "arg1") (error "arg2") (error "arg3") of
    Foo2 x y z -> error "after unpack";
    ;

testFoo2 :: Int;
testFoo2 =
    case Foo2 (error "arg1") (error "arg2") (error "arg3") of
    Foo2 x y z -> error "after unpack";
    ;

testPartialAppsOfFoo = List.length (List.map (Foo 'a' 'b') [error "elem1", error "elem2", error "elem3"]);

testFooUnpacking =
    case Foo "arg1 OK" (error "arg2") (error "arg3") of
    Foo x y z -> x;
    ;

testEmbeddedIf1 x =
    (
        (
            if x > 0 then
                "gt"
            else
                "le"
        )
        ++
        (
            if x == 0 then
                " eq"
            else
                " ne"
        ),
        " zaphod"
    )
    ;

testEmbeddedIf2 x =
    case
        case Prelude.Just ['a'] of
        Prelude.Just xs -> xs;
        Prelude.Nothing -> [];
    of
    y : ys -> y;
    [] -> 'z';
    ;

data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.M2.StringAccumulator" JStringAccumulator;

foreign unsafe import jvm "constructor" makeJStringAccumulator :: JStringAccumulator;

foreign unsafe import jvm "method addString" private jStringAccumulator_AddString :: JStringAccumulator -> String -> String;

foreign unsafe import jvm "method getStrings" private jStringAccumulator_getStrings :: JStringAccumulator -> String;

private accumulateSeq =
    let
        accumulator = makeJStringAccumulator;
    in
        Prelude.seq
            (Prelude.seq
                (Prelude.seq (jStringAccumulator_AddString accumulator "a") (jStringAccumulator_AddString accumulator "b"))
                (jStringAccumulator_AddString accumulator "c")
            )
            (jStringAccumulator_getStrings accumulator)
    ;

private seqArg2 =
    if seq 1.0 (1.0 > 0.0) then
        "true"
    else
        "false"
    ;

private testSeq = accumulateSeq == "a, b, c" && seqArg2 == "true" || Prelude.error "M2.testSeq failed";

private testSeq2 = testSeq2Helper False == 3.5015368232671564;

testSeq2Helper :: Prelude.Boolean -> Prelude.Double;
private testSeq2Helper z =
    let
        x = True;

        y = False;
    in
        seq
            (x && y && z)
            (
                let
                    a = sin 1.0;

                    b = sin 2.0;
                in
                    a + b + a + b
            )
    ;

data SD =
    SD2
        arg1 :: !Prelude.Int
        arg2 :: Prelude.Boolean
        arg3 :: !Prelude.String
    deriving Outputable
    ;

strictDCTest1 :: SD -> Prelude.String;
strictDCTest1 x = "true";

strictDCTest2 :: Prelude.String;
strictDCTest2 =
    let
        accumulator = makeJStringAccumulator;

        result =
            strictDCTest1
                (SD2
                    (Prelude.seq (jStringAccumulator_AddString accumulator "intArg") 1)
                    (Prelude.seq (jStringAccumulator_AddString accumulator "boolArg") Prelude.True)
                    (Prelude.seq (jStringAccumulator_AddString accumulator "stringArg") "stringval")
                )
            ;
    in
        Prelude.seq (Prelude.output result) (jStringAccumulator_getStrings accumulator)
    ;

strictDCTest3 :: String;
strictDCTest3 =
    let
        accumulator = makeJStringAccumulator;

        result =
            SD2
                (Prelude.seq (jStringAccumulator_AddString accumulator "intArg") 1)
                (Prelude.seq (jStringAccumulator_AddString accumulator "boolArg") Prelude.True)
                (Prelude.seq (jStringAccumulator_AddString accumulator "stringArg") "stringval")
            ;
    in
        Prelude.seq (Prelude.output result) (jStringAccumulator_getStrings accumulator)
    ;

strictDCTest4 :: String;
strictDCTest4 =
    let
        accumulator = makeJStringAccumulator;

        partialDC =
            SD2
                (Prelude.seq (jStringAccumulator_AddString accumulator "intArg") 1)
                (Prelude.seq (jStringAccumulator_AddString accumulator "boolArg") Prelude.True)
            ;

        fullDCs =
            List.map
                partialDC
                [
                    Prelude.seq (jStringAccumulator_AddString accumulator "stringArg1") "stringval1",
                    Prelude.seq (jStringAccumulator_AddString accumulator "stringArg2") "stringval2"
                ]
            ;
    in
        Prelude.seq (Prelude.output fullDCs) (jStringAccumulator_getStrings accumulator)
    ;

strictDCTest5 accumulator x = Prelude.seq (jStringAccumulator_AddString accumulator "blah") x;

strictDCTest6 =
    let
        accumulator = makeJStringAccumulator;

        result =
            strictDCTest5
                accumulator
                (SD2
                    (Prelude.seq (jStringAccumulator_AddString accumulator "intArg") 1)
                    (Prelude.seq (jStringAccumulator_AddString accumulator "boolArg") Prelude.True)
                    (Prelude.seq (jStringAccumulator_AddString accumulator "stringArg") "stringval")
                )
            ;
    in
        Prelude.seq (Prelude.output result) (jStringAccumulator_getStrings accumulator)
    ;

strictDCTest7 =
    let
        accumulator = makeJStringAccumulator;
    in
        SD2 (Debug.trace "intArg " 1) (Debug.trace "boolArg " Prelude.True) (Debug.trace "stringArg " "stringval")
    ;

testStrictDataConstructors =
    strictDCTest2 == ""
        && strictDCTest3 == "intArg, stringArg, boolArg"
        && strictDCTest4 == "intArg, stringArg1, boolArg, stringArg2"
        && strictDCTest6 == "blah, intArg, stringArg, boolArg"
    || Prelude.error "Failed in M2.testStrictDataConstructors"
    ;

strictFunction1 :: Prelude.Int -> Prelude.Boolean -> Prelude.String -> Prelude.String;
strictFunction1 !x y !z = "true";

testStrictFunction1 =
    let
        accumulator = makeJStringAccumulator;

        result =
            strictFunction1
                (Prelude.seq (jStringAccumulator_AddString accumulator "intArg") 1)
                (Prelude.seq (jStringAccumulator_AddString accumulator "boolArg") Prelude.True)
                (Prelude.seq (jStringAccumulator_AddString accumulator "stringArg") "stringval")
            ;
    in
        Prelude.seq (Prelude.output result) (jStringAccumulator_getStrings accumulator)
    ;

strictFunction2 :: Prelude.Int -> Prelude.Boolean -> Prelude.String -> Prelude.Int;
strictFunction2 !x y !z = Prelude.seq y (Prelude.seq z x);

testStrictFunction2 =
    let
        accumulator = makeJStringAccumulator;

        result =
            strictFunction2
                (Prelude.seq (jStringAccumulator_AddString accumulator "intArg") 1)
                (Prelude.seq (jStringAccumulator_AddString accumulator "boolArg") Prelude.True)
                (Prelude.seq (jStringAccumulator_AddString accumulator "stringArg") "stringval")
            ;
    in
        Prelude.seq (Prelude.output result) (jStringAccumulator_getStrings accumulator)
    ;

testStrictFunction3 =
    let
        accumulator = makeJStringAccumulator;

        partialAp =
            strictFunction2
                (Prelude.seq (jStringAccumulator_AddString accumulator "intArg") 1)
                (Prelude.seq (jStringAccumulator_AddString accumulator "boolArg") Prelude.True)
            ;

        fullAps =
            List.map
                partialAp
                [
                    Prelude.seq (jStringAccumulator_AddString accumulator "stringArg1") "stringval1",
                    Prelude.seq (jStringAccumulator_AddString accumulator "stringArg2") "stringval2"
                ]
            ;
    in
        Prelude.seq (Prelude.output fullAps) (jStringAccumulator_getStrings accumulator)
    ;

intFunc :: Prelude.Int -> Prelude.Int -> Prelude.Int;
intFunc x y =
    if Prelude.True then
        x
    else
        y
    ;

testStrictFunction4 =
    let
        accumulator = makeJStringAccumulator;

        result =
            strictFunction2
                (Prelude.seq (jStringAccumulator_AddString accumulator "intArg") 1)
                (Prelude.seq (jStringAccumulator_AddString accumulator "boolArg") Prelude.True)
                (Prelude.seq (jStringAccumulator_AddString accumulator "stringArg") "stringval")
            ;
    in
        Prelude.seq (Prelude.output (intFunc 1 result)) (jStringAccumulator_getStrings accumulator)
    ;

testStrictFunctions =
    testStrictFunction1 == "intArg, stringArg"
        && testStrictFunction2 == "intArg, stringArg, boolArg"
        && testStrictFunction3 == "intArg, stringArg1, boolArg, stringArg2"
        && testStrictFunction4 == ""
    || Prelude.error "error in testStrictFunctions"
    ;

nOnes :: Int -> [Int];
nOnes n = replicate n 1;

testMax1 n = List.maximum (nOnes n);

testMax2 n = maximum2 (nOnes n);

max2 :: Ord a => a -> a -> a;
max2 !x !y =
    if x <= y then
        y
    else
        x
    ;

maximum2 :: Ord a => [a] -> a;
maximum2 = List.foldLeft1Strict max2;

testCompare1 n = List.head (List.sort (nOnes n));

testCompare2 n = List.head (sort2 (nOnes n));

sort2 :: Ord a => [a] -> [a];
sort2 = sortBy compare2;

compare2 :: Ord a => a -> a -> Ordering;
compare2 !x !y =
    if x < y then
        LT
    else if x == y then
        EQ
    else
        GT
    ;

sumOld :: Num a => [a] -> a;
sumOld = foldLeftStrict add 0;

sumOldLong :: [Long] -> Long;
sumOldLong = foldLeftStrict add 0;

sumNew :: Num a => [a] -> a;
sumNew !list = sumNewHelper list 0;

sumNewHelper :: Num a => [a] -> a -> a;
private sumNewHelper !list !acc =
    case list of
    [] -> acc;
    listHead : listTail -> sumNewHelper listTail (acc + listHead);
    ;

sumNewLong :: [Long] -> Long;
sumNewLong !list = sumNewLongHelper list 0;

sumNewLongHelper :: [Long] -> Long -> Long;
private sumNewLongHelper !list !acc =
    case list of
    [] -> acc;
    listHead : listTail -> sumNewLongHelper listTail (acc + listHead);
    ;

sumBenchmark1 :: ([Long] -> Long) -> Long;
sumBenchmark1 sum = sum (upFromTo 1 10000000);

testSum =
    sumOld (upFromTo (1 :: Int) 10) == 55
        && sumNew (upFromTo (1 :: Int) 10) == 55
        && sumOld (upFromTo 1.0 10) == 55.0
        && sumNew (upFromTo 1.0 10) == 55.0
    || error "M2.testSum failed."
    ;

/** Test backquoted infix operators */
private class BackquotedTestClass a where
    nonAssociativeOpDouble :: a -> a -> a;
    ;

instance BackquotedTestClass String where
    nonAssociativeOpDouble = backquotedNonAssociativeFunction;
    ;

backquotedNonAssociativeFunction s1 s2 = "a(" ++ s1 ++ ")b(" ++ s2 ++ ")";

data BackquotedTestData =
    BackquotedTestData
        #1 :: Int
        #2 :: Int
    ;

instance Eq BackquotedTestData where
    equals = backquotedTestData_equals;
    notEquals = backquotedTestData_notEquals;
    ;

backquotedTestData_equals :: BackquotedTestData -> BackquotedTestData -> Boolean;
backquotedTestData_equals v1 v2 =
    case v1 of
    BackquotedTestData v1_a1 v1_a2 ->
        case v2 of
        BackquotedTestData v2_a1 v2_a2 -> v1_a1 == v2_a1 && v1_a2 == v2_a2;
        ;
    ;

backquotedTestData_notEquals v1 v2 = not (backquotedTestData_equals v1 v2);

testBackquotedOperators =
    (10 :: Int) `remainder` 2 + 3 == 10 `Prelude.remainder` 2 + 3
        && (3 :: Int) + 10 `remainder` 2 == 3 + 10 `Prelude.remainder` 2
        && (3 :: Int) + 10 `Prelude.remainder` 2 * 1 == 3 + 10 `Prelude.remainder` 2 * 2
        && -10 `Prelude.remainder` (2 :: Int) == -10 `Prelude.remainder` 2
        && (\x -> "a(" ++ x ++ ")") "b" `nonAssociativeOpDouble` "c" == "a(a(b))b(c)"
        && "1" `nonAssociativeOpDouble` "2" `nonAssociativeOpDouble` "3" == "a(a(1)b(2))b(3)"
        && 'a'  `Prelude.Cons`  [] == Cons 'a' []
        && 'a'  `Prelude.Cons`  [] == Cons 'a' []
        && 1  `BackquotedTestData`  2 == BackquotedTestData 1 2
    || error "M2.testBackquotedOperators failed."
    ;

orListOld = foldRight or False;

orListOldExamples :: Boolean;
private orListOldExamples =
    not (orListOld [])
        && orListOld [True]
        && orListOld [False, False, False, True]
        && not (orListOld [False])
        && orListOld [True, True, True]
        && orListOld (repeat True)
        && not (orListOld (replicate 100000 False))
    || error "M2.orListOldExamples failed."
    ;

andListOld :: [Boolean] -> Boolean;
andListOld = foldRight and True;

andListOldExamples :: Boolean;
private andListOldExamples =
    andListOld []
        && andListOld [True]
        && not (andListOld [False])
        && andListOld [True, True, True]
        && not (andListOld (repeat False))
        && not (andListOld (True : False : repeat True))
        && andListOld (replicate 100000 True)
    || error "M2.andListOldExamples failed."
    ;

anyOld :: (a -> Boolean) -> [a] -> Boolean;
anyOld p = Prelude.compose List.orList (List.map p);

anyOldExamples :: Boolean;
private anyOldExamples =
    anyOld (equals 1.0) [2.0, 3.0, 1.0]
        && anyOld (equals "apple") ["pear", "cherry", "peach", "apple", "strawberry"]
        && not (anyOld (equals 1.0) [2.0, 3.0, 5.0])
        && not (anyOld (equals 1.0) [])
        && not (anyOld (greaterThan (0 :: Int)) (upFromTo 1 100))
        && anyOld (greaterThan (0 :: Int)) (upFromTo 1 100 ++ [-1])
        && anyOld (equals (200000 :: Long)) (upFromTo 1 200000)
    || error "M2.anyOldExamples failed."
    ;

benchmarkAny :: ((Long -> Boolean) -> [Long] -> Boolean) -> Long -> Boolean;
benchmarkAny anyFunc n = anyFunc (Prelude.equals n) (upFromTo 1 n);

allOld :: (a -> Boolean) -> [a] -> Boolean;
allOld p = Prelude.compose List.andList (List.map p);

allOldExamples :: Boolean;
private allOldExamples =
    allOld (equals 7.0) [7.0, 7.0, 7.0]
        && allOld (equals 2.0) []
        && allOld (equals "apple") ["apple", "apple"]
        && allOld (equals 1.0) (replicate 100000 1.0)
    || error "Prelude.allOldExamples failed."
    ;

isElemOld :: Eq a => a -> [a] -> Boolean;
isElemOld = Prelude.compose List.any Prelude.equals;

isElemNew :: Eq a => a -> [a] -> Boolean;
isElemNew elem !list =
    case list of
    [] -> False;
    listHead : listTail -> elem == listHead || isElemNew elem listTail;
    ;

lengthOld :: [a] -> Int;
lengthOld = List.foldLeftStrict (\n x -> n + 1) 0;

lengthNew :: [a] -> Int;
lengthNew !list = lengthNewHelper 0 list;

lengthNewHelper :: Int -> [a] -> Int;
private lengthNewHelper !acc !list =
    case list of
    [] -> acc;
    listHead : listTail -> lengthNewHelper (acc + 1) listTail;
    ;

testLength =
    lengthOld (Prelude.upFromTo 1 (50000 :: Long)) == 50000 && lengthNew (Prelude.upFromTo 1 (50000 :: Long)) == 50000
    || error "M2.testLength failed."
    ;

mAnd :: Prelude.Int -> Prelude.Int -> Prelude.Int;
mAnd !x y = 0;

verificationError = mAnd 1 1;

ternaryTest vals =
    case vals of
    [] -> [];
    v : vs ->
        let
            z =
                if v > 0.0 then
                    []
                else
                    [v]
                ;
        in
            z ++ ternaryTest vs
        ;
    ;

findIndicesOld :: (a -> Boolean) -> [a] -> [Int];
findIndicesOld p xs = map snd (filter (compose p fst) (zip xs (upFrom 0)));

findIndicesNew :: (a -> Boolean) -> [a] -> [Int];
findIndicesNew p !list = findIndicesHelper p 0 list;

findIndicesHelper :: (a -> Boolean) -> Int -> [a] -> [Int];
private findIndicesHelper p !currentIndex !list =
    case list of
    [] -> [];
    listHead : listTail ->
        if p listHead then
            currentIndex : findIndicesHelper p (currentIndex + 1) listTail
        else
            findIndicesHelper p (currentIndex + 1) listTail
        ;
    ;

testFindIndices =
    findIndicesOld isEven [1 :: Int, 1, 4, 1, 2, 1, 1, 6] == [2, 4, 7]
        && findIndicesNew isEven [1 :: Int, 1, 4, 1, 2, 1, 1, 6] == [2, 4, 7]
        && List.length (findIndicesOld Prelude.isEven (Prelude.upFromTo 1 (10000 :: Int))) == 5000
        && List.length (findIndicesNew Prelude.isEven (Prelude.upFromTo 1 (10000 :: Int))) == 5000
    || error "M2.testFindIndices failed."
    ;

removeDuplicatesByNew :: (a -> a -> Boolean) -> [a] -> [a];
removeDuplicatesByNew eq !list = removeDuplicatesByNewHelper eq list [];

removeDuplicatesByNewHelper :: (a -> a -> Boolean) -> [a] -> [a] -> [a];
private removeDuplicatesByNewHelper eq !list accList =
    case list of
    [] -> [];
    listHead : listTail ->
        if isElemBy eq listHead accList then
            removeDuplicatesByNewHelper eq listTail accList
        else
            listHead : removeDuplicatesByNewHelper eq listTail (listHead : accList)
        ;
    ;

removeDuplicatesByOld :: (a -> a -> Boolean) -> [a] -> [a];
removeDuplicatesByOld eq !xs =
    let
        notEq eq x y = not (eq x y);
    in
        case xs of
        [] -> [];
        xs_head : xs_tail -> xs_head : removeDuplicatesByOld eq (filter (notEq eq xs_head) xs_tail);
    ;

private removeDuplicatesByOldExamples =
    removeDuplicatesByOld Prelude.equals [3.0, 3, 1, 1, 3, 4, 1] == [3, 1, 4]
        && removeDuplicatesByOld Prelude.equals (toList "delete = deleteBy equals;") == toList "delt =Byquas;"
        && length (removeDuplicatesByOld Prelude.equals (Prelude.upFromTo (1 :: Long) 50)) == 50
        && length (removeDuplicatesByOld Prelude.equals (List.replicate 10000 'a')) == 1
    || error "M2.removeDuplicatesOldExamples failed."
    ;

sumUp :: Long -> Long;
sumUp !n = sumUpHelper n 0;

sumUpHelper :: Long -> Long -> Long;
sumUpHelper !n !acc =
    if n == 0 then
        acc
    else
        sumUpHelper (n - 1) (acc + n)
    ;

letters :: [Char];
letters =
    let
        abcde = 'a' : bcdea;

        bcdea = 'b' : cdeab;

        cdeab = 'c' : deabc;

        deabc = 'd' : eabcd;

        eabcd = 'e' : abcde;
    in
        abcde
    ;

letters2 :: [Char];
letters2 =
    let
        bcdea = 'B' : cdeab;

        deabc = 'D' : eabcd;

        eabcd = 'E' : abcde;

        abcde = 'A' : bcdea;

        cdeab = 'C' : deabc;
    in
        abcde
    ;

testLetters =
    drop 99994 (take 100000 letters) == ['e', 'a', 'b', 'c', 'd', 'e']
        && drop 99994 (take 100000 letters2) == ['E', 'A', 'B', 'C', 'D', 'E']
    || error "M2.testLetters failed."
    ;

testLiftTests =
    liftTest1 1 == (9, 29)
        && liftTest2 7 == 17
        && liftTest3 50 100 == (200, 150)
        && liftTest4 "hello" == 50
        && liftTest5 9 99 == [-509, -507, -502]
        && liftTest5_1 9 99 == [-509, -507, -502]
        && liftTest5_2 9 99 == [-509, -507, -502]
        && lifter 10 == 135
        && lifter2 100 1 == 5050
    || error "M2.testLiftTests failed."
    ;

liftTest1 x =
    let
        liftTest1 u v = u * v - x;
    in
        (liftTest1 2.0 5.0, liftTest1 5.0 6.0)
    ;

liftTest2 liftTest2 =
    (
        let
            liftTest2 liftTest2 v = liftTest2 * v;
        in
            liftTest2 5.0 2.0
    )
    + liftTest2
    ;

liftTest3 :: Int -> Int -> (Int, Int);
liftTest3 u v =
    let
        f v =
            if v == 0 then
                v
            else
                u + g (v - 1)
            ;

        g u =
            if u == 0 then
                u
            else
                v + f (u - 1)
            ;
    in
        (f 3, g 2)
    ;

liftTest4 :: String -> Int;
liftTest4 str =
    let
        f x = String.length str + g (x - 1);

        g str =
            if str == 0 then
                str
            else
                f (str - 0)
            ;
    in
        g 10
    ;

liftTest5 :: Int -> Int -> [Int];
liftTest5 x y =
    let
        g u v = u - 2 * x + 3 * v - 5 * y;
    in
        [g 1 1, g 3 1, g 2 3]
    ;

liftTest5_1 :: Int -> Int -> [Int];
liftTest5_1 x y =
    let
        g = liftTest5_1_helper x y;
    in
        [g 1 1, g 3 1, g 2 3]
    ;

liftTest5_1_helper x y u v = u - 2 * x + 3 * v - 5 * y;

liftTest5_2 :: Int -> Int -> [Int];
liftTest5_2 x y = [liftTest5_2_helper x y 1 1, liftTest5_2_helper x y 3 1, liftTest5_2_helper x y 2 3];

liftTest5_2_helper x y u v = u - 2 * x + 3 * v - 5 * y;

liftTest6 x y =
    let
        g p = h p + x;

        h q = k + y + q;

        k = g y;
    in
        g 4.0
    ;

liftTest6_1 x y =
    let
        k = liftTest6_g x y k y;
    in
        liftTest6_g x y k 4.0
    ;

liftTest6_g x y k p = liftTest6_h x y k p + x;

liftTest6_h x y k q = k + y + q;

data Stuff =
    Stuff stuff :: Prelude.Integer
    ;

instance Eq Stuff where
    equals = equalsStuff;
    notEquals = notEqualsStuff;
    ;

private equalsStuff s1 s2 =
    case s1 of
    Stuff v1 ->
        case s2 of
        Stuff v2 -> v1 == v2;
        ;
    ;

private notEqualsStuff s1 s2 = not (equalsStuff s1 s2);

testStuff =
    not
        (
            let
                equalsStuff :: Stuff -> Stuff -> Boolean;
                equalsStuff calc1 calc2 = equals calc1 calc2;
            in
                equalsStuff (Stuff 1) (Stuff 2)
        )
    ;

sum2 :: [Long] -> Long;
sum2 !list =
    let
        sum2Helper :: [Long] -> Long -> Long;
        sum2Helper !list !acc =
            case list of
            [] -> acc;
            listHead : listTail -> sum2Helper listTail (acc + listHead);
            ;
    in
        sum2Helper list 0
    ;

sum2LiftedTraditionally :: [Long] -> Long;
sum2LiftedTraditionally !list =
    let
        sum2Helper :: [Long] -> Long -> Long;
        sum2Helper = sum2HelperLiftedTraditionally sum2Helper;
    in
        sum2Helper list 0
    ;

sum2HelperLiftedTraditionally :: ([Long] -> Long -> Long) -> [Long] -> Long -> Long;
sum2HelperLiftedTraditionally sum2Helper !list !acc =
    case list of
    [] -> acc;
    listHead : listTail -> sum2Helper listTail (acc + listHead);
    ;

sum2JohnssonLifted :: [Long] -> Long;
sum2JohnssonLifted !list = sum2HelperJohnssonLifted list 0;

sum2HelperJohnssonLifted :: [Long] -> Long -> Long;
private sum2HelperJohnssonLifted !list !acc =
    case list of
    [] -> acc;
    listHead : listTail -> sum2HelperJohnssonLifted listTail (acc + listHead);
    ;

lifter :: Int -> Int;
lifter !x =
    let
        f y =
            let
                g z =
                    let
                        h w = x + 2 * y + 3 * z + 4 * w;
                    in
                        h (z + 3)
                    ;
            in
                g (y + 2)
            ;
    in
        f (x + 1)
    ;

lifter2 :: Int -> Int -> Int;
lifter2 n w =
    let
        f x =
            let
                g y =
                    let
                        h z =
                            if z == 0 then
                                0
                            else
                                f (x - w) + z
                            ;
                    in
                        h y
                    ;
            in
                g x
            ;
    in
        f n
    ;

testArgTypeLifting :: Prelude.Char -> [Prelude.Char] -> Prelude.Boolean -> Prelude.Int -> Prelude.Double;
testArgTypeLifting charArg !strictListCharArg boolArg !strictIntArg =
    let
        f localDouble !strictLocalInteger localMaybeInt =
            (
                strictIntArg,
                charArg,
                strictListCharArg,
                boolArg,
                Math.sin localDouble,
                [strictLocalInteger, 2 :: Prelude.Integer],
                [localMaybeInt, Prelude.Just (2 :: Int)]
            )
            ;
    in
        2.0
    ;

equalsFunny = Prelude.equals;

outputListWithOld :: [a] -> (a -> JObject) -> JList;
outputListWithOld !list elementMappingFunction =
    let
        foldFunction !javaList element =
            if jList_add javaList (elementMappingFunction element) then
                javaList
            else
                error "List.outputListWith: adding an element to a Java list failed."
            ;
    in
        foldLeftStrict foldFunction jArrayList_new list
    ;

foreign unsafe import jvm "constructor java.util.ArrayList" private jArrayList_new :: JList;

foreign unsafe import jvm "method add" private jList_add :: JList -> JObject -> Boolean;

foreign unsafe import jvm "method size" private jList_size :: JList -> Int;

foreign unsafe import jvm "method get" private jList_get :: JList -> Int -> JObject;

foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.M2.Cast.objectToList"
    cast_JObjectToJList :: JObject -> JList;

testOutputListWithOld =
    Prelude.input (Prelude.output (outputListWithOld (upFromTo 1.0 5.0) Prelude.output)) == [1.0, 2.0, 3.0, 4.0, 5.0]
    && Prelude.input (Prelude.output (outputListWithOld (upFromTo LT GT) Prelude.output)) == [LT, EQ, GT]
    ;

inputListWithOld :: JList -> (JObject -> a) -> [a];
inputListWithOld !javaList elementMappingFunction =
    map (compose elementMappingFunction (jList_get javaList)) (take (jList_size javaList) (upFrom 0));

testInputListWithOld =
    List.sum
        (inputListWithOld
            (cast_JObjectToJList (Prelude.output (upFromTo (1 :: Int) 1000)))
            Prelude.input
        )
        + (0 :: Int)
    == 500500
    ;

recUnzip3 :: [{field1 :: a, field2 :: b, field3 :: c}] -> {field1 :: [a], field2 :: [b], field3 :: [c]};
recUnzip3 !list =
    case list of
    [] -> {field1 = [], field2 = [], field3 = []};
    x : xs ->
        let
            ys = recUnzip3 xs;
        in
            case x of
            {field1 = x1, field2 = x2, field3 = x3} ->
                {field1 = x1 : ys.field1, field2 = x2 : ys.field2, field3 = x3 : ys.field3};
        ;
    ;

tupRecUnzip3 :: [{#1 :: a, #2 :: b, #3 :: c}] -> {#1 :: [a], #2 :: [b], #3 :: [c]};
tupRecUnzip3 !list =
    case list of
    [] -> {#1 = [], #2 = [], #3 = []};
    x : xs ->
        let
            ys = tupRecUnzip3 xs;
        in
            case x of
            {#1 = x1, #2 = x2, #3 = x3} -> {#1 = x1 : ys.#1, #2 = x2 : ys.#2, #3 = x3 : ys.#3};
        ;
    ;

tupleData :: Int -> [(String, Int, Int)];
tupleData !n =
    let
        tupleDataHelper !i =
            if i == n then
                []
            else
                ("Anton", i, n - i) : tupleDataHelper (i + 1)
            ;
    in
        tupleDataHelper 0
    ;

recData :: Int -> [{field1 :: String, field2 :: Int, field3 :: Int}];
recData !n =
    let
        recDataHelper !i =
            if i == n then
                []
            else
                {field1 = "Anton", field2 = i, field3 = n - i} : recDataHelper (i + 1)
            ;
    in
        recDataHelper 0
    ;

tupRecData :: Int -> [{#1 :: String, #2 :: Int, #3 :: Int}];
tupRecData !n =
    let
        recDataHelper !i =
            if i == n then
                []
            else
                {#1 = "Anton", #2 = i, #3 = n - i} : recDataHelper (i + 1)
            ;
    in
        recDataHelper 0
    ;

tupleSumLast :: Int -> Int;
tupleSumLast n = sum (map field3 (tupleData n));

fieldNamedField3 !x = x.field3;

recSumLast :: Int -> Int;
recSumLast n = sum (map fieldNamedField3 (recData n));

tupRecField3 !x = x.#3;

tupRecSumLast :: Int -> Int;
tupRecSumLast n = sum (map tupRecField3 (tupRecData n));

tupleSort :: Int -> Int;
tupleSort n = field3 (last (sortBy (\x y -> compare (field3 x) (field3 y)) (tupleData n)));

recSort :: Int -> Int;
recSort n = (last (sortBy (\x y -> compare x.field3 y.field3) (recData n))).field3;

tupRecSort :: Int -> Int;
tupRecSort n = (last (sortBy (\x y -> compare x.#3 y.#3) (tupRecData n))).#3;

tupleUnzip :: Int -> Int;
tupleUnzip n = length (field3 (unzip3 (tupleData n)));

recUnzip :: Int -> Int;
recUnzip n = length (recUnzip3 (recData n)).field3;

tupRecUnzip :: Int -> Int;
tupRecUnzip n = length (tupRecUnzip3 (tupRecData n)).#3;

workbookTupleData :: Int -> [(String, Int)];
workbookTupleData n =
    List.take n (List.zip (List.cycle ["Minuet", "Waltz", "Sarabande", "Courante", "Gigue"]) (Prelude.upFrom (1 :: Int)))
    ;

workbookBenchmark4TupleSimulation :: Int -> [([(String, Int)], Int)];
workbookBenchmark4TupleSimulation n =
    let
        primaryChannel = workbookTupleData n;

        sortedData = sortBy (\x y -> compare (fst x) (fst y)) primaryChannel;

        groupedData :: [[(String, Int)]];
        groupedData = groupBy (\x y -> fst x == fst y) sortedData;

        summary :: [Int];
        summary = map (\listOfPairs -> sum (snd (unzip listOfPairs))) groupedData;
    in
        zip groupedData summary
    ;

recZip :: [a] -> [b] -> [{field1 :: a, field2 :: b}];
recZip !list1 list2 =
    case list1 of
    x : xs ->
        case list2 of
        y : ys -> {field1 = x, field2 = y} : recZip xs ys;
        [] -> [];
        ;
    [] -> [];
    ;

recUnzip2 :: [{field1 :: a, field2 :: b}] -> {field1 :: [a], field2 :: [b]};
recUnzip2 !list =
    case list of
    [] -> {field1 = [], field2 = []};
    x : xs ->
        let
            ys = recUnzip2 xs;
        in
            case x of
            {field1 = x1, field2 = x2} -> {field1 = x1 : ys.field1, field2 = x2 : ys.field2};
        ;
    ;

workbookRecData :: Int -> [{field1 :: String, field2 :: Int}];
workbookRecData n =
    List.take n (recZip (List.cycle ["Minuet", "Waltz", "Sarabande", "Courante", "Gigue"]) (Prelude.upFrom (1 :: Int)));

workbookBenchmark4RecSimulation :: Int -> [([{field1 :: String, field2 :: Int}], Int)];
workbookBenchmark4RecSimulation n =
    let
        primaryChannel = workbookRecData n;

        sortedData = sortBy (\x y -> compare x.field1 y.field1) primaryChannel;

        groupedData :: [[{field1 :: String, field2 :: Int}]];
        groupedData = groupBy (\x y -> x.field1 == y.field1) sortedData;

        summary :: [Int];
        summary = map (\listOfRecs -> sum (recUnzip2 listOfRecs).field2) groupedData;
    in
        zip groupedData summary
    ;

tupRecZip :: [a] -> [b] -> [{#1 :: a, #2 :: b}];
tupRecZip !list1 list2 =
    case list1 of
    x : xs ->
        case list2 of
        y : ys -> {#1 = x, #2 = y} : tupRecZip xs ys;
        [] -> [];
        ;
    [] -> [];
    ;

tupRecUnzip2 :: [{#1 :: a, #2 :: b}] -> {#1 :: [a], #2 :: [b]};
tupRecUnzip2 !list =
    case list of
    [] -> {#1 = [], #2 = []};
    x : xs ->
        let
            ys = tupRecUnzip2 xs;
        in
            case x of
            {#1 = x1, #2 = x2} -> {#1 = x1 : ys.#1, #2 = x2 : ys.#2};
        ;
    ;

workbookTupRecData :: Int -> [{#1 :: String, #2 :: Int}];
workbookTupRecData n =
    List.take n (tupRecZip (List.cycle ["Minuet", "Waltz", "Sarabande", "Courante", "Gigue"]) (Prelude.upFrom (1 :: Int)))
    ;

workbookBenchmark4TupRecSimulation :: Int -> [([{#1 :: String, #2 :: Int}], Int)];
workbookBenchmark4TupRecSimulation n =
    let
        primaryChannel = workbookTupRecData n;

        sortedData = sortBy (\x y -> compare x.#1 y.#1) primaryChannel;

        groupedData :: [[{#1 :: String, #2 :: Int}]];
        groupedData = groupBy (\x y -> x.#1 == y.#1) sortedData;

        summary :: [Int];
        summary = map (\listOfRecs -> sum (tupRecUnzip2 listOfRecs).#2) groupedData;
    in
        zip groupedData summary
    ;

bigTupleData :: Int -> [(String, Int, Int, Int, Int, Int, Int)];
bigTupleData !n =
    let
        tupleDataHelper !i =
            if i == n then
                []
            else
                ("Anton", i, n - i, 40, 50, 60, 70) : tupleDataHelper (i + 1)
            ;
    in
        tupleDataHelper 0
    ;

bigRecData ::
    Int -> [{field1 :: String, field2 :: Int, field3 :: Int, field4 :: Int, field5 :: Int, field6 :: Int, field7 :: Int}];

bigRecData !n =
    let
        recDataHelper !i =
            if i == n then
                []
            else
                {field1 = "Anton", field2 = i, field3 = n - i, field4 = 40, field5 = 50, field6 = 60, field7 = 70}
                : recDataHelper (i + 1)
            ;
    in
        recDataHelper 0
    ;

bigTupRecData :: Int -> [{#1 :: String, #2 :: Int, #3 :: Int, #4 :: Int, #5 :: Int, #6 :: Int, #7 :: Int}];

bigTupRecData !n =
    let
        recDataHelper !i =
            if i == n then
                []
            else
                {#1 = "Anton", #2 = i, #3 = n - i, #4 = 40, #5 = 50, #6 = 60, #7 = 70} : recDataHelper (i + 1)
            ;
    in
        recDataHelper 0
    ;

textualUnit :: Prelude.Unit;
textualUnit = ();

textualTuple :: {#1 :: Double, #2 :: Char};
textualTuple = (2.0, 'a');

textualFunction :: Prelude.Function a a;
textualFunction = Prelude.id;

textualList :: Prelude.List a -> a;
textualList = List.head;

textualList2 :: Prelude.Function (Prelude.List a) a;
textualList2 = List.head;

testExpressionTypeSignatures =
    (1 :: Int) == 1
        &&
        (
            let
                myFst = Prelude.fst :: ([Int], Char) -> [Prelude.Int];
            in
                myFst ([], 'a')
        )
            == []
        &&
        (
            let
                myFst2 = Prelude.fst :: ([a], a) -> [a];
            in
                myFst2 ([], 'a')
        )
            == []
        &&
        (
            let
                myFst3 = Prelude.fst :: Num a => (a, a) -> a;
            in
                myFst3 (2, 5 :: Int)
        )
            == 2
    || error "M2.testExpressionTypeSignatures failed."
    ;

class EqAlt a => OrdAlt a where
    lessThanAlt :: a -> a -> Boolean;
    minAlt :: a -> a -> a;
    ;

class EqAlt a where
    equalsAlt :: a -> a -> Boolean;
    notEqualsAlt :: a -> a -> Boolean;
    ;

class EqAlt a => NumAlt a where
    addAlt :: a -> a -> a;
    subtractAlt :: a -> a -> a;
    ;

class (OrdAlt a, NumAlt a, BoundedAlt a) => EnumAlt a where
    upFromToAlt :: a -> a -> [a];
    ;

class BoundedAlt a where
    minBoundAlt :: a;
    maxBoundAlt :: a;
    ;

class ShowAlt a where
    showAlt :: a -> String;
    ;

instance EqAlt Int where
    equalsAlt = equalsAltInt;
    notEqualsAlt = notEqualsAltInt;
    ;

equalsAltInt :: Int -> Int -> Boolean;
equalsAltInt = Prelude.equals;

notEqualsAltInt :: Int -> Int -> Boolean;
notEqualsAltInt = Prelude.notEquals;

instance OrdAlt Int where
    lessThanAlt = lessThanAltInt;
    minAlt = minAltInt;
    ;

lessThanAltInt :: Int -> Int -> Boolean;
lessThanAltInt = Prelude.lessThan;

minAltInt :: Int -> Int -> Int;
minAltInt = Prelude.min;

instance NumAlt Int where
    addAlt = addAltInt;
    subtractAlt = subtractAltInt;
    ;

addAltInt :: Int -> Int -> Int;
addAltInt = Prelude.add;

subtractAltInt :: Int -> Int -> Int;
subtractAltInt = Prelude.subtract;

instance EnumAlt Int where
    upFromToAlt = upFromToAltInt;
    ;

upFromToAltInt :: Int -> Int -> [Int];
upFromToAltInt = Prelude.upFromTo;

instance BoundedAlt Int where
    minBoundAlt = minBoundAltInt;
    maxBoundAlt = maxBoundAltInt;
    ;

minBoundAltInt :: Int;
minBoundAltInt = Prelude.minBound;

maxBoundAltInt :: Int;
maxBoundAltInt = Prelude.maxBound;

instance ShowAlt Int where
    showAlt = showAltInt;
    ;

showAltInt :: Int -> String;
showAltInt = Prelude.intToString;

instance EqAlt a => EqAlt (Maybe a) where
    equalsAlt = equalsAltMaybe;
    notEqualsAlt = notEqualsAltMaybe;
    ;

equalsAltMaybe :: EqAlt a => Maybe a -> Maybe a -> Boolean;
private equalsAltMaybe !m1 !m2 =
    case m1 of
    Nothing ->
        case m2 of
        Nothing -> True;
        Just x2 -> False;
        ;
    Just x1 ->
        case m2 of
        Nothing -> False;
        Just x2 -> equalsAlt x1 x2;
        ;
    ;

notEqualsAltMaybe :: EqAlt a => Maybe a -> Maybe a -> Boolean;
notEqualsAltMaybe !m1 !m2 = Prelude.not (equalsAlt m1 m2);

instance OrdAlt a => OrdAlt (Maybe a) where
    lessThanAlt = lessThanAltMaybe;
    minAlt = minAltMaybe;
    ;

lessThanAltMaybe :: OrdAlt a => Maybe a -> Maybe a -> Boolean;
private lessThanAltMaybe !m1 !m2 =
    case m1 of
    Nothing ->
        case m2 of
        Nothing -> False;
        Just x2 -> True;
        ;
    Just x1 ->
        case m2 of
        Nothing -> False;
        Just x2 -> lessThanAlt x1 x2;
        ;
    ;

minAltMaybe :: OrdAlt a => Maybe a -> Maybe a -> Maybe a;
private minAltMaybe !x !y =
    if lessThanAlt x y then
        x
    else
        y
    ;

instance NumAlt a => NumAlt (Maybe a) where
    addAlt = addAltMaybe;
    subtractAlt = subtractAltMaybe;
    ;

addAltMaybe :: NumAlt a => Maybe a -> Maybe a -> Maybe a;
addAltMaybe !m1 !m2 =
    case m1 of
    Nothing -> Nothing;
    Just x1 ->
        case m2 of
        Nothing -> Nothing;
        Just x2 -> Just (addAlt x1 x2);
        ;
    ;

subtractAltMaybe :: NumAlt a => Maybe a -> Maybe a -> Maybe a;
subtractAltMaybe !m1 !m2 =
    case m1 of
    Nothing -> Nothing;
    Just x1 ->
        case m2 of
        Nothing -> Nothing;
        Just x2 -> Just (subtractAlt x1 x2);
        ;
    ;

instance EnumAlt a => EnumAlt (Maybe a) where
    upFromToAlt = upFromToAltMaybe;
    ;

upFromToAltMaybe :: EnumAlt a => Maybe a -> Maybe a -> [Maybe a];
upFromToAltMaybe !m1 !m2 =
    case m1 of
    Nothing ->
        case m2 of
        Nothing -> [Nothing];
        Just x2 -> Nothing : map Just (upFromToAlt minBoundAlt x2);
        ;
    Just x1 ->
        case m2 of
        Nothing -> [];
        Just x2 -> map Just (upFromToAlt x1 x2);
        ;
    ;

instance BoundedAlt a => BoundedAlt (Maybe a) where
    minBoundAlt = minBoundAltMaybe;
    maxBoundAlt = maxBoundAltMaybe;
    ;

minBoundAltMaybe :: BoundedAlt a => Maybe a;
minBoundAltMaybe = Nothing;

maxBoundAltMaybe :: BoundedAlt a => Maybe a;
maxBoundAltMaybe = Just maxBoundAlt;

instance ShowAlt a => ShowAlt (Maybe a) where
    showAlt = showAltMaybe;
    ;

showAltMaybe :: ShowAlt a => Maybe a -> String;
showAltMaybe !m =
    case m of
    Nothing -> "Nothing";
    Just x -> "(Just " ++ showAlt x ++ ")";
    ;

ai1 :: (EnumAlt a, ShowAlt a) => a -> a -> ([Boolean], [a], [a], String, String);
ai1 x y =
    (
        [equalsAlt x y, notEqualsAlt x y, lessThanAlt x y],
        [minAlt x y, addAlt x y, subtractAlt x y, minBoundAlt, maxBoundAlt],
        upFromToAlt x y,
        showAlt x,
        showAlt y
    )
    ;

ai2 :: (EnumAlt a, ShowAlt a) => a -> a -> (a, Boolean, a);
ai2 x y = ai2Helper x y;

ai2Helper :: (NumAlt a, OrdAlt a, BoundedAlt b) => a -> a -> (b, Boolean, a);
ai2Helper x y = (maxBoundAlt, lessThanAlt x y, subtractAlt x y);

testAltInstances =
    ai1 (5 :: Int) 7 == ([False, True, True], [5, 12, -2, Prelude.minBound, Prelude.maxBound], [5, 6, 7], "5", "7")
        && ai1 (Just (5 :: Int)) (Just 7)
            ==
            (
                [False, True, True],
                [Just 5, Just 12, Just (-2), Nothing, Just Prelude.maxBound],
                [Just 5, Just 6, Just 7],
                "(Just 5)",
                "(Just 7)"
            )
        && ai1 (Nothing :: Maybe (Maybe Int)) Nothing
            ==
            (
                [True, False, False],
                [Nothing, Nothing, Nothing, Nothing, Just (Just Prelude.maxBound)],
                [Nothing],
                "Nothing",
                "Nothing"
            )
        && ai2 (9 :: Int) 20 == (Prelude.maxBound, True, -11)
        && ai2 (Just (9 :: Int)) (Just 20) == (Just Prelude.maxBound, True, Just (-11))
        && ai2 (Nothing :: Maybe (Maybe (Maybe Int))) Nothing == (Just (Just (Just Prelude.maxBound)), False, Nothing)
    || error "M2.testAltInstances failed."
    ;

capsTest = 1.0;

capstest = 2.0;

lpt1 = 3.0;

lPt1 = 4.0;

aux = 5.0;

aUx = 6.0;

data CapsTestType1 =
    CTT1A |
    CTT1a |
    Ctt1a
    ;

data Capstesttype1 =
    CTt1A |
    CtT1a |
    CtT1A
    ;

capsData1Test x =
    case x of
    CTT1A -> "CTT1A";
    CTT1a -> "CTT1a";
    Ctt1a -> "Ctt1a";
    ;

capsData2Test x =
    case x of
    CTt1A -> "CTt1A";
    CtT1a -> "CtT1a";
    CtT1A -> "CtT1A";
    ;

class CapsShow f where
    sHOw :: f -> Prelude.String;
    ;

class Capsshow f where
    shOw :: f -> Prelude.String;
    ;

instance CapsShow CapsTestType1 where
    sHOw = sHOwCapsTestType1;
    ;

instance Capsshow CapsTestType1 where
    shOw = shOwCapsTestType1;
    ;

instance CapsShow Capstesttype1 where
    sHOw = sHOwCapstesttype1;
    ;

instance Capsshow Capstesttype1 where
    shOw = shOwCapstesttype1;
    ;

sHOwCapsTestType1 x = "sHOwCapsTestType1" ++ capsData1Test x;

shOwCapsTestType1 x = "shOwCapsTestType1" ++ capsData1Test x;

sHOwCapstesttype1 x = "sHOwCapstesttype1" ++ capsData2Test x;

shOwCapstesttype1 x = "shOwCapstesttype1" ++ capsData2Test x;

instanceShow1 :: CapsShow a => a -> String;
instanceShow1 a = sHOw a;

instanceShow2 :: Capsshow a => a -> String;
instanceShow2 a = shOw a;

capsArgs :: Prelude.Double -> Prelude.Double -> Prelude.Double;
capsArgs arg aRg = arg - aRg;

capsLets :: Prelude.Double -> Prelude.Double -> Prelude.Double;
capsLets arg aRg =
    let
        foo = arg;

        foO = aRg;
    in
        foo + foo - (foO + foO)
    ;

caseTest =
    capsTest == 1.0
    && capstest == 2.0
    && lpt1 == 3.0
    && lPt1 == 4.0
    && aux == 5.0
    && aUx == 6.0
    && capsData1Test CTT1A == "CTT1A"
    && capsData1Test CTT1a == "CTT1a"
    && capsData1Test Ctt1a == "Ctt1a"
    && capsData2Test CTt1A == "CTt1A"
    && capsData2Test CtT1a == "CtT1a"
    && capsData2Test CtT1A == "CtT1A"
    && instanceShow1 CTt1A == "sHOwCapstesttype1CTt1A"
    && instanceShow1 CTT1A == "sHOwCapsTestType1CTT1A"
    && capsArgs 5.0 3.0 == 2.0
    && capsLets 5.0 3.0 == 4.0
    ;

aliasTest1 :: Prelude.Double -> Prelude.Double -> Prelude.Double;
aliasTest1 x y = aliasTest2 x y;

aliasTest2 :: Prelude.Double -> Prelude.Double -> Prelude.Double;
aliasTest2 x y = aliasTest3 x y;

aliasTest3 :: Prelude.Double -> Prelude.Double -> Prelude.Double;
aliasTest3 x y = aliasTest1 x y;

testInlinedLetInTailRecursion x y =
    let
        pair = (x, y);

        fp = Prelude.fst pair;

        sp = Prelude.snd pair;
    in
        if fp > 0.0 then
            Prelude.False
        else
            testInlinedLetInTailRecursion (x - 1) sp
    ;

data RE =
    RDC1
    ;

equalsRE :: RE -> RE -> Prelude.Boolean;
private equalsRE !x !y =
    case x of
    RDC1 ->
        case y of
        RDC1 -> Prelude.True;
        _ -> Prelude.False;
        ;
    ;

combinations :: [[a]] -> [[a]];
combinations !valuesLists =
    let
        comboHelper newValues currentCombos =
            foldRight (\newVal cur -> map (Prelude.Cons newVal) currentCombos ++ cur) [] newValues;
    in
        if Prelude.isEmpty valuesLists then
            []
        else
            foldRight comboHelper (map List.list1 (last valuesLists)) (List.init valuesLists)
    ;

combinations2 :: [[a]] -> [[a]];
combinations2 !listOfValues =
    let
        combine :: [a] -> [[a]] -> [[a]];
        combine xs yss =
            case xs of
            [] -> [];
            xs_head : xs_tail -> scalarCombine xs_head yss ++ combine xs_tail yss;
            ;

        scalarCombine :: a -> [[a]] -> [[a]];
        scalarCombine x !yss =
            case yss of
            [] -> [];
            ys : yss_tail -> (x : ys) : scalarCombine x yss_tail;
            ;

        combine1 :: [a] -> [[a]];
        combine1 !xs =
            case xs of
            [] -> [];
            x : xs_tail -> [x] : combine1 xs_tail;
            ;
    in
        case listOfValues of
        [] -> [];
        listOfValues_head : listOfValues_tail ->
            if Prelude.isEmpty listOfValues_tail then
                combine1 listOfValues_head
            else
                combine listOfValues_head (combinations2 listOfValues_tail)
            ;
    ;

cft combinations listOfValues =
    let
        listOfValues = [countryDimension, productsDimension, timeDimension, measuresDimension];
    in
        Prelude.seq (Prelude.output (combinations listOfValues)) "done"
    ;

comboFunctionalityTest comboFunction =
    comboFunction [] == ([] :: [[Char]])
        && comboFunction [['a']] == [['a']]
        && comboFunction [['a', 'b', 'c']] == [['a'], ['b'], ['c']]
        && comboFunction [[], ['a', 'b', 'c']] == []
        && comboFunction [['a', 'b', 'c'], []] == []
        && comboFunction [['a', 'b', 'c'], ['1', '2']]
            == [['a', '1'], ['a', '2'], ['b', '1'], ['b', '2'], ['c', '1'], ['c', '2']]
        && comboFunction [['a'], ['b'], ['c']] == [['a', 'b', 'c']]
    || error "M2.comboFunctionalityTest failed."
    ;

comboTest1 comboFunction = last (comboFunction [countryDimension, productsDimension, timeDimension, measuresDimension]);

comboTest2 comboFunction = length (comboFunction [countryDimension, productsDimension, timeDimension, measuresDimension]);

comboTest3 comboFunction =
    sum (map length (comboFunction [countryDimension, productsDimension, timeDimension, measuresDimension]));

countryDimension = ["Canada", "USA", "Mexico", "France", "UK", "Spain", "Italy", "Germany", "Portugal", "Denmark"];

productsDimension = map (\!i -> "Products" ++ Prelude.intToString i) (upFromTo 1 100);

timeDimension = map (\!i -> "Time" ++ Prelude.intToString i) (upFromTo 1 100);

measuresDimension = ["Sales", "Costs", "Profit"];

outputCharTest = Prelude.output 'c';

groupByFirst :: (a -> a -> Boolean) -> [(a, b)] -> [(a, [b])];
groupByFirst eq tuples =
    case tuples of
    [] -> [];
    tuples_head : tuples_tail ->
        let
            comparisonTarget = fst tuples_head;

            partitionedTuples = partition (\x -> eq comparisonTarget (fst x)) tuples_tail;

            eqTuples = tuples_head : fst partitionedTuples;

            eqCombinedTuple = (comparisonTarget, map snd eqTuples);

            notEqTuples = snd partitionedTuples;
        in
            eqCombinedTuple : groupByFirst eq notEqTuples
        ;
    ;

groupByFirst2 :: (a -> a -> Boolean) -> [(a, b)] -> [(a, [b])];
groupByFirst2 eqFunc !lst =
    let
        groupByFirstHelper :: (a -> a -> Boolean) -> [(a, [b])] -> (a, b) -> [(a, [b])];
        groupByFirstHelper eqFunc !tuples nextTuple =
            case tuples of
            [] -> [(fst nextTuple, [snd nextTuple])];
            tuples_head : tuples_tail ->
                let
                    key = fst tuples_head;

                    values = snd tuples_head;

                    nextKey = fst nextTuple;

                    nextValue = snd nextTuple;
                in
                    if eqFunc key nextKey then
                        (key, nextValue : values) : tuples_tail
                    else
                        tuples_head : groupByFirstHelper eqFunc tuples_tail nextTuple
                ;
            ;
    in
        foldLeft (groupByFirstHelper eqFunc) [] lst
    ;

testTupleListWorst :: Int -> [(Int, Int)];
testTupleListWorst n =
    let
        keys = upFrom 1;

        values = List.repeat 0;
    in
        take n (zip keys values)
    ;

testGroupFirsts n = groupByFirst2 equals (testTupleListWorst n);

groupByFirsts3 :: (a -> a -> Ordering) -> [(a, b)] -> [(a, [b])];
groupByFirsts3 compare list =
    let
        compareFunction p1 p2 = compare (fst p1) (fst p2);

        eqFunction p1 p2 = compareFunction p1 p2 == EQ;

        sortThenGroupByFirsts = List.groupBy eqFunction (List.sortBy compareFunction list);

        collapse listOfPairs =
            let
                pairOfLists = unzip listOfPairs;
            in
                (List.head (fst pairOfLists), snd pairOfLists)
            ;
    in
        map collapse sortThenGroupByFirsts
    ;

select2 :: (a -> Boolean) -> a -> ([a], [a]) -> ([a], [a]);
private select2 !p x tfs =
    if p x then
        (x : fst tfs, snd tfs)
    else
        (fst tfs, x : snd tfs)
    ;

partition2 :: (a -> Boolean) -> [a] -> ([a], [a]);
partition2 p xs = foldRight (select2 p) ([], []) xs;

groupAllBy :: (a -> a -> Boolean) -> [a] -> [[a]];
groupAllBy eqFunc !lst =
    let
        groupValue :: (a -> a -> Boolean) -> [[a]] -> a -> [[a]];
        groupValue eqFunc groups value =
            case groups of
            [] -> [[value]];
            x : xs ->
                if eqFunc value (head x) then
                    (value : x) : xs
                else
                    x : groupValue eqFunc xs value
                ;
            ;
    in
        foldLeft (groupValue eqFunc) [] lst
    ;

testGroupAllBy n = groupAllBy equals (upFromTo (1 :: Int) n);

groupAllBy2 :: (a -> a -> Boolean) -> [a] -> [[a]];
groupAllBy2 eqFunc !lst =
    let
        groupValue :: (a -> a -> Boolean) -> a -> [[a]] -> [[a]];
        groupValue eqFunc value !groups =
            case groups of
            [] -> [[value]];
            x : xs ->
                if eqFunc value (head x) then
                    (value : x) : xs
                else
                    x : groupValue eqFunc value xs
                ;
            ;
    in
        foldRight (groupValue eqFunc) [] lst
    ;

testGroupAllBy2 n = groupAllBy2 equals (upFromTo (1 :: Int) n);

groupAllBy3 :: (a -> a -> Boolean) -> [a] -> [[a]];
groupAllBy3 eq list =
    case list of
    [] -> [];
    headList : tailList ->
        case partition (eq headList) tailList of
        (fstEquivClass, restOfList) -> (headList : fstEquivClass) : groupAllBy3 eq restOfList;
        ;
    ;

testGroupAllBy3 n = groupAllBy3 equals (upFromTo (1 :: Int) n);

groupAllBy4 :: (a -> a -> Boolean) -> [a] -> [[a]];
groupAllBy4 eqFunc !lst =
    let
        groupValue :: (a -> a -> Boolean) -> [[a]] -> a -> [[a]] -> [[a]];
        groupValue eqFunc groups value !remainingGroups =
            case remainingGroups of
            [] -> [value] : groups;
            x : xs ->
                if eqFunc value (head x) then
                    (value : x) : xs
                else
                    x : groupValue eqFunc groups value xs
                ;
            ;
    in
        foldRight (groupValue eqFunc []) [] lst
    ;

testGroupAllBy4 n = groupAllBy4 equals (upFromTo (1 :: Int) n);

groupAllBy5 :: (a -> a -> Boolean) -> [a] -> [[a]];
groupAllBy5 eqFunc list =
    let
        groupAllByHelper :: (a -> a -> Boolean) -> [a] -> [[a]] -> [[a]];
        groupAllByHelper eq !list equivClassesOfLists =
            case list of
            [] -> equivClassesOfLists;
            listHead : listTail -> groupAllByHelper eq listTail (groupValue eq listHead equivClassesOfLists);
            ;

        groupValue :: (a -> a -> Boolean) -> a -> [[a]] -> [[a]];
        groupValue eq value !list =
            case list of
            [] -> [[value]];
            listHead : listTail ->
                if eq value (head listHead) then
                    (value : listHead) : listTail
                else
                    listHead : groupValue eq value listTail
                ;
            ;
    in
        groupAllByHelper eqFunc list []
    ;

testGroupAllBy5 n = groupAllBy5 equals (upFromTo (1 :: Int) n);

equivalentToHead :: (a -> a -> Boolean) -> [a] -> [a];
equivalentToHead eq list =
    case list of
    [] -> [];
    listHead : listTail -> listHead : filter (eq listHead) listTail;
    ;

testGroupAllByGeneral func =
    func (\p q -> fst p == fst q) [('a', 1.0), ('a', 2.0), ('b', 3.0), ('c', 4.0), ('a', 5.0), ('b', 6.0)]
    == [[('a', 1.0), ('a', 2.0), ('a', 5.0)], [('b', 3.0), ('b', 6.0)], [('c', 4.0)]]
    ;

groupByFirst3 :: (a -> a -> Boolean) -> [(a, b)] -> [(a, [b])];
groupByFirst3 eq list =
    map (\listOfPairs -> (fst (head listOfPairs), map snd listOfPairs)) (groupAllBy3 (\p q -> eq (fst p) (fst q)) list)
    ;

groupAllByFirstBug :: Prelude.Eq a => [(a, b)] -> [(a, [b])];
groupAllByFirstBug list =
    List.map
        (\lop -> (Prelude.fst (List.head lop), List.map Prelude.snd lop))
        (groupAllBy3 ((\eq p q -> eq (Prelude.fst p) (Prelude.fst q)) Prelude.equals) list)
    ;

groupAllByFirstBug2 :: (a -> a -> Prelude.Boolean) -> [(a, b)] -> [(a, [b])];
groupAllByFirstBug2 eq list =
    List.map
        (\lop -> (Prelude.fst (List.head lop), List.map Prelude.snd lop))
        (groupAllBy3 ((\eq p q -> eq (Prelude.fst p) (Prelude.fst q)) eq) list)
    ;

sortIntExternal :: [Int] -> [Int];
sortIntExternal list =
    let
        javaList = outputList list;
    in
        seq (jSort javaList) (inputList javaList)
    ;

foreign unsafe import jvm "static method java.util.Collections.sort" private jSort :: JList -> ();

countDown :: Int -> [Int];
countDown n = Prelude.upFromThenTo n (n - 1) 1;

testSort f n = last (f (countDown n));

testSort2 f n = head (f (countDown n));

z1 :: Int -> Boolean;
z1 !x = 0 < x;

zAndAnd :: Boolean -> Boolean -> Boolean -> Boolean;
zAndAnd !x !y !z = x && y && z;

zOrOr :: Boolean -> Boolean -> Boolean -> Boolean;
zOrOr !x !y !z = x || y || z;

zOrAnd :: Boolean -> Boolean -> Boolean -> Boolean;
zOrAnd !x !y !z = x || y && z;

zAndOr :: Boolean -> Boolean -> Boolean -> Boolean;
zAndOr !x !y !z = x && y || z;

zAndAndOr :: Boolean -> Boolean -> Boolean -> Boolean -> Boolean;
zAndAndOr !x !y !z !w = x && y && z || w;

opTestNotAnd x y = not (x && y);

opTestNotOr x y = not (x || y);

opTestNotNot x = not (not x);

opTestEquals :: Int -> Int -> Boolean;
opTestEquals x y = x == y;

opTestEquals2 :: Int -> Int -> Boolean;
opTestEquals2 x y = not (x != y);

opTestNotEquals :: Int -> Int -> Boolean;
opTestNotEquals x y = x != y;

opTestNotEquals2 :: Int -> Int -> Boolean;
opTestNotEquals2 x y = not (x == y);

opTestLessThan :: Int -> Int -> Boolean;
opTestLessThan x y = x < y;

opTestLessThan2 :: Int -> Int -> Boolean;
opTestLessThan2 x y = not (x >= y);

opTestLessThanEquals :: Int -> Int -> Boolean;
opTestLessThanEquals x y = x <= y;

opTestLessThanEquals2 :: Int -> Int -> Boolean;
opTestLessThanEquals2 x y = not (x > y);

opTestGreaterThan :: Int -> Int -> Boolean;
opTestGreaterThan x y = x > y;

opTestGreaterThan2 :: Int -> Int -> Boolean;
opTestGreaterThan2 x y = not (x <= y);

opTestGreaterThanEquals :: Int -> Int -> Boolean;
opTestGreaterThanEquals x y = x >= y;

opTestGreaterThanEquals2 :: Int -> Int -> Boolean;
opTestGreaterThanEquals2 x y = not (x < y);

opTestDoubleEquals :: Double -> Double -> Boolean;
opTestDoubleEquals x y = x == y;

opTestDoubleEquals2 :: Double -> Double -> Boolean;
opTestDoubleEquals2 x y = not (x != y);

opTestDoubleNotEquals :: Double -> Double -> Boolean;
opTestDoubleNotEquals x y = x != y;

opTestDoubleNotEquals2 :: Double -> Double -> Boolean;
opTestDoubleNotEquals2 x y = not (x == y);

opTestDoubleLessThan :: Double -> Double -> Boolean;
opTestDoubleLessThan x y = x < y;

opTestDoubleLessThan2 :: Double -> Double -> Boolean;
opTestDoubleLessThan2 x y = not (x >= y);

opTestDoubleLessThanEquals :: Double -> Double -> Boolean;
opTestDoubleLessThanEquals x y = x <= y;

opTestDoubleLessThanEquals2 :: Double -> Double -> Boolean;
opTestDoubleLessThanEquals2 x y = not (x > y);

opTestDoubleGreaterThan :: Double -> Double -> Boolean;
opTestDoubleGreaterThan x y = x > y;

opTestDoubleGreaterThan2 :: Double -> Double -> Boolean;
opTestDoubleGreaterThan2 x y = not (x <= y);

opTestDoubleGreaterThanEquals :: Double -> Double -> Boolean;
opTestDoubleGreaterThanEquals x y = x >= y;

opTestDoubleGreaterThanEquals2 :: Double -> Double -> Boolean;
opTestDoubleGreaterThanEquals2 x y = not (x < y);

opTestCompareOr1 :: Int -> Int -> Boolean;
opTestCompareOr1 x y = x < 1 || y < 5;

opTestCompareOr2 :: Int -> Int -> Int -> Boolean;
opTestCompareOr2 x y z = x < 1 || y < 5 || z < 10;

opTestCompareOrStrict1 :: Int -> Int -> Boolean;
opTestCompareOrStrict1 !x !y = x < 1 || y < 5;

opTestCompareOrStrict2 :: Int -> Int -> Int -> Boolean;
opTestCompareOrStrict2 !x !y !z = x < 1 || y < 5 || z < 10;

id2 :: Boolean -> Boolean;
id2 !x = x;

opTestExAnd x y = id2 (x && y);

opTestExOr x y = id2 (x || y);

opTestExNot x = id2 (not x);

opTestExNotAnd x y = id2 (not (x && y));

opTestExNotOr x y = id2 (not (x || y));

opTestExNotNot x = id2 (not (not x));

opTestExEquals :: Int -> Int -> Boolean;
opTestExEquals x y = id2 (x == y);

opTestExEquals2 :: Int -> Int -> Boolean;
opTestExEquals2 x y = id2 (not (x != y));

opTestExNotEquals :: Int -> Int -> Boolean;
opTestExNotEquals x y = id2 (x != y);

opTestExNotEquals2 :: Int -> Int -> Boolean;
opTestExNotEquals2 x y = id2 (not (x == y));

opTestExLessThan :: Int -> Int -> Boolean;
opTestExLessThan x y = id2 (x < y);

opTestExLessThan2 :: Int -> Int -> Boolean;
opTestExLessThan2 x y = id2 (not (x >= y));

opTestExLessThanEquals :: Int -> Int -> Boolean;
opTestExLessThanEquals x y = id2 (x <= y);

opTestExLessThanEquals2 :: Int -> Int -> Boolean;
opTestExLessThanEquals2 x y = id2 (not (x > y));

opTestExGreaterThan :: Int -> Int -> Boolean;
opTestExGreaterThan x y = id2 (x > y);

opTestExGreaterThan2 :: Int -> Int -> Boolean;
opTestExGreaterThan2 x y = id2 (not (x <= y));

opTestExGreaterThanEquals :: Int -> Int -> Boolean;
opTestExGreaterThanEquals x y = id2 (x >= y);

opTestExGreaterThanEquals2 :: Int -> Int -> Boolean;
opTestExGreaterThanEquals2 x y = id2 (not (x < y));

opTestExDoubleEquals :: Double -> Double -> Boolean;
opTestExDoubleEquals x y = id2 (x == y);

opTestExDoubleEquals2 :: Double -> Double -> Boolean;
opTestExDoubleEquals2 x y = id2 (not (x != y));

opTestExDoubleNotEquals :: Double -> Double -> Boolean;
opTestExDoubleNotEquals x y = id2 (x != y);

opTestExDoubleNotEquals2 :: Double -> Double -> Boolean;
opTestExDoubleNotEquals2 x y = id2 (not (x == y));

opTestExDoubleLessThan :: Double -> Double -> Boolean;
opTestExDoubleLessThan x y = id2 (x < y);

opTestExDoubleLessThan2 :: Double -> Double -> Boolean;
opTestExDoubleLessThan2 x y = id2 (not (x >= y));

opTestExDoubleLessThanEquals :: Double -> Double -> Boolean;
opTestExDoubleLessThanEquals x y = id2 (x <= y);

opTestExDoubleLessThanEquals2 :: Double -> Double -> Boolean;
opTestExDoubleLessThanEquals2 x y = id2 (not (x > y));

opTestExDoubleGreaterThan :: Double -> Double -> Boolean;
opTestExDoubleGreaterThan x y = id2 (x > y);

opTestExDoubleGreaterThan2 :: Double -> Double -> Boolean;
opTestExDoubleGreaterThan2 x y = id2 (not (x <= y));

opTestExDoubleGreaterThanEquals :: Double -> Double -> Boolean;
opTestExDoubleGreaterThanEquals x y = id2 (x >= y);

opTestExDoubleGreaterThanEquals2 :: Double -> Double -> Boolean;
opTestExDoubleGreaterThanEquals2 x y = id2 (not (x < y));

opTestExCompareOr1 :: Int -> Int -> Boolean;
opTestExCompareOr1 x y = id2 (x < 1 || y < 5);

opTestExCompareOr2 :: Int -> Int -> Int -> Boolean;
opTestExCompareOr2 x y z = id2 (x < 1 || y < 5 || z < 10);

opTestExCompareOrStrict1 :: Int -> Int -> Boolean;
opTestExCompareOrStrict1 !x !y = id2 (x < 1 || y < 5);

opTestExCompareOrStrict2 :: Int -> Int -> Int -> Boolean;
opTestExCompareOrStrict2 !x !y !z = id2 (x < 1 || y < 5 || z < 10);

opTestExParenAndOr x y z = id2 (x && y || z);

opTestExNotParenAndOr x y z = id2 (not (x && y) || z);

opTestExParenAndNotOr x y z = id2 (x && y || not z);

opTestExNotParenAndNotOr x y z = id2 (not (x && y) || not z);

opTestExAndParenOr x y z = id2 (x && (y || z));

opTestExNotAndParenOr x y z = id2 (not x && (y || z));

opTestExAndNotParenOr x y z = id2 (x && not (y || z));

opTestExNotAndNotParenOr x y z = id2 (not x && not (y || z));

opTestExParenOrAnd x y z = id2 ((x || y) && z);

opTestExNotParenOrAnd x y z = id2 (not (x || y) && z);

opTestExParenOrNotAnd x y z = id2 ((x || y) && not z);

opTestExNotParenOrNotAnd x y z = id2 (not (x || y) && not z);

opTestExOrParenAnd x y z = id2 (x || y && z);

opTestExNotOrParenAnd x y z = id2 (not x || y && z);

opTestExOrNotParenAnd x y z = id2 (x || not (y && z));

opTestExNotOrNotParenAnd x y z = id2 (not x || not (y && z));

opTestExAndAnd x y z = id2 ((x && y) && z);

opTestExNotAndAnd x y z = id2 (not (x && y) && z);

opTestExAndNotAnd x y z = id2 ((x && y) && not z);

opTestExNotAndNotAnd x y z = id2 (not (x && y) && not z);

opTestExAndAnd2 x y z = id2 (x && y && z);

opTestExNotAndAnd2 x y z = id2 (not x && y && z);

opTestExAndNotAnd2 x y z = id2 (x && not (y && z));

opTestExNotAndNotAnd2 x y z = id2 (not x && not (y && z));

opTestExOrOr x y z = id2 ((x || y) || z);

opTestExNotOrOr x y z = id2 (not (x || y) || z);

opTestExOrNotOr x y z = id2 ((x || y) || not z);

opTestExNotOrNotOr x y z = id2 (not (x || y) || not z);

opTestExOrOr2 x y z = id2 (x || y || z);

opTestExNotOrOr2 x y z = id2 (not x || y || z);

opTestExOrNotOr2 x y z = id2 (x || not (y || z));

opTestExNotOrNotOr2 x y z = id2 (not x || not (y || z));

opTestExExtendedTests1 x1 x2 x3 x4 x5 = id2 ((((x1 || x2) || x3) || x4) || x5);

opTestExExtendedTests2 x1 x2 x3 x4 x5 = id2 ((((x1 && x2) && x3) && x4) && x5);

opTestExExtendedTests3 x1 x2 x3 x4 x5 = id2 (x1 || x2 || x3 || x4 || x5);

opTestExExtendedTests4 x1 x2 x3 x4 x5 = id2 (x1 && x2 && x3 && x4 && x5);

opTestExExtendedTests5 x1 x2 x3 x4 x5 =
    id2
        (not
            (not (not (not (x1 || x2) || x3) || x4) || x5)
        )
    ;

opTestExExtendedTests6 x1 x2 x3 x4 x5 =
    id2
        (not
            (not (not (not (x1 && x2) && x3) && x4) && x5)
        )
    ;

opTestExExtendedTests7 x1 x2 x3 x4 x5 =
    id2
        (not
            (x1 || not (x2 || not (x3 || not (x4 || x5))))
        )
    ;

opTestExExtendedTests8 x1 x2 x3 x4 x5 =
    id2
        (not
            (x1 && not (x2 && not (x3 && not (x4 && x5))))
        )
    ;

opTestExExtendedTests7b x2 x3 x4 x5 = id2 (not (x2 || not (x3 || not (x4 || x5))));

opTestExExtendedTests8b x2 x3 x4 x5 = id2 (not (x2 && not (x3 && not (x4 && x5))));

opTestExExtendedTests9 x1 x2 x3 x4 x5 y2 y4 = id2 ((((sin x1 < sin y2 || x2) || cos x3 != cos y4) || x4) || x5);

opTestExExtendedTests10 x1 x2 x3 x4 x5 y2 y4 = id2 ((((sin x1 < sin y2 && x2) && cos x3 != cos y4) && x4) && x5);

opTestExExtendedTests11 x1 x2 x3 x4 x5 y2 y4 = id2 (sin x1 < sin y2 || x2 || cos x3 != cos y4 || x4 || x5);

opTestExExtendedTests12 x1 x2 x3 x4 x5 y2 y4 = id2 (sin x1 < sin y2 && x2 && cos x3 != cos y4 && x4 && x5);

opTestExExtendedTests13 x1 x2 x3 x4 x5 y2 y4 =
    id2
        (not
            (not (not (not (sin x1 < sin y2 || x2) || cos x3 != cos y4) || x4) || x5)
        )
    ;

opTestExExtendedTests14 x1 x2 x3 x4 x5 y2 y4 =
    id2
        (not
            (not (not (not (sin x1 < sin y2 && x2) && cos x3 != cos y4) && x4) && x5)
        )
    ;

opTestExExtendedTests15 x1 x2 x3 x4 x5 y2 y4 =
    id2
        (not
            (sin x1 < sin y2 || not (x2 || not (cos x3 != cos y4 || not (x4 || x5))))
        )
    ;

opTestExExtendedTests16 x1 x2 x3 x4 x5 y2 y4 =
    id2
        (not
            (sin x1 < sin y2 && not (x2 && not (cos x3 != cos y4 && not (x4 && x5))))
        )
    ;

opTestExExtendedTests17 x1 x2 x3 x4 x5 x6 x7 x8 = id2 (((x1 && x2) && x3 && x4) && (x5 && x6) && x7 && x8);

opTestExExtendedTests18 x1 x2 x3 x4 x5 x6 x7 x8 = id2 (((x1 || x2) || x3 || x4) || (x5 || x6) || x7 || x8);

opTestExExtendedTests19 x1 x2 x3 x4 x5 x6 x7 x8 = id2 (((x1 || x2) || x3 || x4) && ((x5 || x6) || x7 || x8));

opTestExExtendedTests20 x1 x2 x3 x4 x5 x6 x7 x8 = id2 ((x1 && x2 || x3 && x4) || x5 && x6 || x7 && x8);

opTestExExtendedTests21 x1 x2 x3 x4 x5 x6 x7 x8 = id2 ((x1 && x2 || x3 && x4) && (x5 && x6 || x7 && x8));

opTestExExtendedTests22 x1 x2 x3 x4 x5 x6 x7 x8 = id2 ((x1 || x2) && (x3 || x4) || (x5 || x6) && (x7 || x8));

opTestExExtendedTests23 x1 x2 x3 x4 x5 x6 x7 x8 =
    id2
        (not
            (
                not (not (not x1 && not x2) && not (not x3 && not x4))
                && not (not (not x5 && not x6) && not (not x7 && not x8))
            )
        )
    ;

opTestExExtendedTests24 x1 x2 x3 x4 x5 x6 x7 x8 =
    id2
        (not
            (
                not (not (not x1 || not x2) || not (not x3 || not x4))
                || not (not (not x5 || not x6) || not (not x7 || not x8))
            )
        )
    ;

opTestExExtendedTests25 x1 x2 x3 x4 x5 x6 x7 x8 =
    id2
        (not
            (
                not (not (not x1 || not x2) || not (not x3 || not x4))
                && not (not (not x5 || not x6) || not (not x7 || not x8))
            )
        )
    ;

opTestExExtendedTests26 x1 x2 x3 x4 x5 x6 x7 x8 =
    id2
        (not
            (
                not (not (not x1 && not x2) || not (not x3 && not x4))
                || not (not (not x5 && not x6) || not (not x7 && not x8))
            )
        )
    ;

opTestExExtendedTests27 x1 x2 x3 x4 x5 x6 x7 x8 =
    id2
        (not
            (
                not (not (not x1 && not x2) || not (not x3 && not x4))
                && not (not (not x5 && not x6) || not (not x7 && not x8))
            )
        )
    ;

opTestExExtendedTests28 x1 x2 x3 x4 x5 x6 x7 x8 =
    id2
        (not
            (
                not (not (not x1 || not x2) && not (not x3 || not x4))
                || not (not (not x5 || not x6) && not (not x7 || not x8))
            )
        )
    ;

opTestExExtendedTests29 x1 x2 x3 x4 x5 y2 y4 =
    id2
        (not
            (
                not (not (not (not (sin x1 < sin y2) || x2) || not (cos x3 != cos y4)) || x4) || x5
            )
        )
    ;

opTestExExtendedTests30 x1 x2 x3 x4 x5 y2 y4 =
    id2
        (not
            (
                not (not (not (not (sin x1 < sin y2) && x2) && not (cos x3 != cos y4)) && x4) && x5
            )
        )
    ;

opTestExExtendedTests31 x1 x2 x3 x4 x5 y2 y4 =
    id2
        (not
            (not (sin x1 < sin y2) || not (x2 || not (not (cos x3 != cos y4) || not (x4 || x5))))
        )
    ;

opTestExExtendedTests32 x1 x2 x3 x4 x5 y2 y4 =
    id2
        (not
            (not (sin x1 < sin y2) && not (x2 && not (not (cos x3 != cos y4) && not (x4 && x5))))
        )
    ;

opTestExExtendedTests33 x1 x2 x3 x4 x5 y2 y4 =
    id2
        (not
            (
                not
                    (
                        not (not (not ((abs x1 :: Int) < abs y2) || x2) || not ((abs x3 :: Int) != abs y4)) || x4
                    )
                || x5
            )
        )
    ;

opTestExExtendedTests34 x1 x2 x3 x4 x5 y2 y4 =
    id2
        (not
            (
                not
                    (
                        not (not (not ((abs x1 :: Int) < abs y2) && x2) && not ((abs x3 :: Int) != abs y4)) && x4
                    )
                && x5
            )
        )
    ;

opTestExExtendedTests35 x1 x2 x3 x4 x5 y2 y4 =
    id2
        (not
            (
                not ((abs x1 :: Int) < abs y2)
                || not (x2 || not (not ((abs x3 :: Int) != abs y4) || not (x4 || x5)))
            )
        )
    ;

opTestExExtendedTests36 x1 x2 x3 x4 x5 y2 y4 =
    id2
        (not
            (
                not ((abs x1 :: Int) < abs y2)
                && not (x2 && not (not ((abs x3 :: Int) != abs y4) && not (x4 && x5)))
            )
        )
    ;

outputTest1 = Prelude.output (5.0, "abc");

outputTest2 = Prelude.output {#1 = 5.0, #2 = "abc"};

recordCaseWithTailRecursionAndLetVariables ::
    {f1 :: Prelude.Integer, f2 :: Prelude.Integer, f3 :: Prelude.Integer, f4 :: Prelude.Integer}
    -> [Prelude.Integer]
    -> [Prelude.Integer];
recordCaseWithTailRecursionAndLetVariables abcd xss =
    case abcd of
    {f1 = a, f2 = b, f3 = c, f4 = d} ->
        let
            q = b / d;
        in
            if
                (Prelude.signum c == Prelude.signum d || Prelude.abs c < Prelude.abs d)
                && (c + d) * q <= a + b
                && (c + d) * q + (c + d) > a + b
            then
                q : recordCaseWithTailRecursionAndLetVariables {f1 = c, f2 = d, f3 = a - q * c, f4 = b - q * d} xss
            else
                case xss of
                x : xs -> recordCaseWithTailRecursionAndLetVariables {f1 = b, f2 = a + x * b, f3 = d, f4 = c + x * d} xs;
        ;
    ;

testLetVarInlining =
    let
        accumulator = makeJStringAccumulator;

        testLetVarInliningHelper :: Ord a => JStringAccumulator -> [a] -> [a] -> Ordering;
        testLetVarInliningHelper accumulator !xs !ys =
            case xs of
            [] ->
                case ys of
                [] -> EQ;
                ys_head : ys_tail -> LT;
                ;
            xs_head : xs_tail ->
                case ys of
                [] -> GT;
                ys_head : ys_tail ->
                    let
                        compareHeads =
                            Prelude.seq
                                (jStringAccumulator_AddString accumulator "evaluate compareHeads")
                                (compare xs_head ys_head)
                            ;
                    in
                        case compareHeads of
                        EQ -> testLetVarInliningHelper accumulator xs_tail ys_tail;
                        _ -> compareHeads;
                    ;
                ;
            ;
    in
        if
            Prelude.seq (testLetVarInliningHelper accumulator [1.0] [2.0]) (jStringAccumulator_getStrings accumulator)
            == "evaluate compareHeads"
        then
            Prelude.True
        else
            Prelude.error "M2.testLetVarInlining failed."
    ;

myFacAcc :: Prelude.Integer -> Prelude.Integer -> Prelude.Integer;
private myFacAcc !a !n =
    if n == 0 then
        a
    else
        myFacAcc (n * a) (n - 1)
    ;

myFactorial :: Prelude.Integer -> Prelude.Integer;
myFactorial !n = myFacAcc 1 n;

myFactorial2 :: Prelude.Integer -> Prelude.Integer;
myFactorial2 n = List.product (Prelude.upFromTo 1 n);

benchmarkFixedTuple5 n =
    last
        (
            Prelude.input (Prelude.output (replicate n (1.0, "Anton", 3 :: Int, True, 'a')))
                :: [(Double, String, Int, Boolean, Char)]
        )
    ;

benchmarkFixedTuple2 n = last (Prelude.input (Prelude.output (replicate n (1.0, "Anton"))) :: [(Double, String)]);

benchmarkFixedList5 n = last (Prelude.input (Prelude.output (replicate n [10 :: Int, 20, 30, 40, 50])) :: [[Int]]);

benchmarkFixedList2 n = last (Prelude.input (Prelude.output (replicate n [10 :: Int, 20])) :: [[Int]]);

outIn :: (Outputable a, Inputable a) => a -> a;
outIn x = Prelude.input (Prelude.output x);

testRecordOutIn =
    outIn {} == {}
        && outIn {#1 = 34.0} == {#1 = 34.0}
        && outIn ("Apple", 5.0) == ("Apple", 5.0)
        && outIn (2 :: Int, "Muppet", True) == (2 :: Int, "Muppet", True)
        && outIn (55 :: Int, "Arthur", 2.0, False) == outIn (55 :: Int, "Arthur", 2.0, False)
        && outIn (55 :: Int, "Arthur", 2.0, False, 35.0) == (55 :: Int, "Arthur", 2.0, False, 35.0)
        && outIn (2 :: Int, "Muppet", True, "Pear", 20.0, 'f') == (2 :: Int, "Muppet", True, "Pear", 20.0, 'f')
        && outIn ([2 :: Int], "Muppet", [True], "Pear", 20.0, 'f', "Linda")
            == ([2 :: Int], "Muppet", [True], "Pear", 20.0, 'f', "Linda")
        && outIn ([2 :: Int], "Muppet", [True], "Pear", 20.0, 'f', ["Linda", "Anton"], Just 4.0)
            == ([2 :: Int], "Muppet", [True], "Pear", 20.0, 'f', ["Linda", "Anton"], Just 4.0)
        && outIn ("Apple", [2 :: Int], "Muppet", [True], "Pear", 20.0, 'f', ["Linda", "Anton"], Just 4.0)
            == ("Apple", [2 :: Int], "Muppet", [True], "Pear", 20.0, 'f', ["Linda", "Anton"], Just 4.0)
    || error "M2.testRecordOutIn failed."
    ;

testListOutIn =
    outIn ([] :: [Int]) == []
        && outIn [10 :: Int] == [10]
        && outIn [10 :: Int, 20] == [10, 20]
        && outIn [10 :: Int, 20, 30] == [10, 20, 30]
        && outIn [10 :: Int, 20, 30, 40] == [10, 20, 30, 40]
        && outIn [10 :: Int, 20, 30, 40, 50] == [10 :: Int, 20, 30, 40, 50]
        && outIn [10 :: Int, 20, 30, 40, 50, 60] == [10 :: Int, 20, 30, 40, 50, 60]
        && outIn [10 :: Int, 20, 30, 40, 50, 60, 70] == [10 :: Int, 20, 30, 40, 50, 60, 70]
        && outIn [10 :: Int, 20, 30, 40, 50, 60, 70, 80] == [10 :: Int, 20, 30, 40, 50, 60, 70, 80]
        && outIn [10 :: Int, 20, 30, 40, 50, 60, 70, 80, 90] == [10 :: Int, 20, 30, 40, 50, 60, 70, 80, 90]
    || error "M2.testListOutIn failed."
    ;

newTupData :: Int -> [(Char, Int, Int, Int)];
newTupData !n =
    let
        tupHelper :: Int -> [(Char, Int, Int, Int)] -> [(Char, Int, Int, Int)];
        tupHelper !i acc =
            if i == n then
                acc
            else
                tupHelper (i + 1) (('c', i, n - i, n + i) : acc)
            ;
    in
        tupHelper 0 []
    ;

oldTupData :: Int -> [LegacyTuple.Tuple4 Char Int Int Int];
oldTupData !n =
    let
        tupHelper :: Int -> [LegacyTuple.Tuple4 Char Int Int Int] -> [LegacyTuple.Tuple4 Char Int Int Int];
        tupHelper !i acc =
            if i == n then
                acc
            else
                tupHelper (i + 1) (LegacyTuple.Tuple4 'c' i (n - i) (n + i) : acc)
            ;
    in
        tupHelper 0 []
    ;

oldElementEquals n =
    let
        forward = oldTupData n;

        backward = List.reverse forward;

        pwiseEq x y =
            equals (LegacyTuple.tuple4Field1 x) (LegacyTuple.tuple4Field1 y)
            && equals (LegacyTuple.tuple4Field2 x) (LegacyTuple.tuple4Field2 y)
            && equals (LegacyTuple.tuple4Field3 x) (LegacyTuple.tuple4Field3 y)
            && equals (LegacyTuple.tuple4Field4 x) (LegacyTuple.tuple4Field4 y)
            ;
    in
        List.zipWith pwiseEq forward backward ++ List.zipWith pwiseEq forward forward
    ;

newElementEquals n =
    let
        forward = newTupData n;

        backward = List.reverse forward;

        pwiseEq x y =
            equals (Prelude.field1 x) (Prelude.field1 y)
            && equals (Prelude.field2 x) (Prelude.field2 y)
            && equals (Prelude.field3 x) (Prelude.field3 y)
            && equals (Prelude.field4 x) (Prelude.field4 y)
            ;
    in
        List.zipWith pwiseEq forward backward ++ List.zipWith pwiseEq forward forward
    ;

newMethodEquals n =
    let
        forward = newTupData n;

        backward = List.reverse forward;
    in
        List.zipWith equals forward backward ++ List.zipWith equals forward forward
    ;

oldMethodEquals n =
    let
        forward = oldTupData n;

        backward = List.reverse forward;
    in
        List.zipWith equals forward backward ++ List.zipWith equals forward forward
    ;

average :: [Double] -> Double;
average !xs = sum xs / toDouble (length xs);

average2 :: Num a => [a] -> Double;
average2 !xs = average (map toDouble xs);

average3 :: Num a => [a] -> Double;
average3 !xs =
    let
        average3Helper :: Num a => [a] -> Double -> Int -> Double;
        average3Helper !xs !partialSum !partialLength =
            case xs of
            [] ->
                if partialLength == 0 then
                    Prelude.notANumber
                else
                    partialSum / toDouble partialLength
                ;
            xsHead : xsTail -> average3Helper xsTail (partialSum + toDouble xsHead) (partialLength + 1);
            ;
    in
        average3Helper xs 0 0
    ;

average4 :: [Double] -> Double;
average4 !xs =
    let
        average4Helper :: [Double] -> Double -> Int -> Double;
        average4Helper !xs !partialSum !partialLength =
            case xs of
            [] ->
                if partialLength == 0 then
                    Prelude.notANumber
                else
                    partialSum / toDouble partialLength
                ;
            xsHead : xsTail -> average4Helper xsTail (partialSum + xsHead) (partialLength + 1);
            ;
    in
        average4Helper xs 0 0
    ;

average5 :: (Num a, Typeable a) => [a] -> Double;
average5 !xs =
    if typeOf xs == typeOf ([] :: [Double]) then
        average4 (unsafeCoerce xs)
    else
        average3 xs
    ;

average6 :: (Num a, Typeable a) => [a] -> Double;
average6 !xs = average4 (unsafeCoerce xs);

averagePlinged :: [Double] -> Double;
averagePlinged !xs = sum xs / toDouble (length xs);

averageIndirect :: Boolean -> [Double] -> Double;
averageIndirect !b !xs = averagePlinged xs;

numToString :: (Num a, Typeable a) => a -> String;
numToString n =
    if typeOf n == typeOf (1 :: Int) then
        Prelude.intToString (unsafeCoerce n)
    else if typeOf n == typeOf (1 :: Prelude.Integer) then
        Prelude.integerToString (unsafeCoerce n)
    else
        Prelude.doubleToString (toDouble n)
    ;

expandedList :: Int -> [Double];
expandedList n =
    let
        list = upFromTo (1 :: Double) (toDouble n);
    in
        seq (last list) list
    ;

expandedListOfPairs :: Int -> [(Int, Int)];
expandedListOfPairs n =
    let
        list = upFromTo (1 :: Int) n;

        pairedList = zip list list;
    in
        seq (last pairedList) pairedList
    ;

mapFst :: r\#1 => [{r | #1 :: a}] -> [a];
mapFst !listOfRecords =
    case listOfRecords of
    headListOfRecords : tailListOfRecords -> headListOfRecords.#1 : mapFst tailListOfRecords;
    [] -> [];
    ;

benchmarkMapFst1 n = sum (map Prelude.fst (expandedListOfPairs n));

benchmarkMapFst2 n = sum (map Prelude.field1 (expandedListOfPairs n));

benchmarkMapFst3 n = sum (mapFst (expandedListOfPairs n));

mapJust :: (a -> Maybe b) -> [a] -> [b];
mapJust f list = List.map Prelude.fromJust (filter Prelude.isJust (List.map f list));

mapJust2 :: (a -> Maybe b) -> [a] -> [b];
mapJust2 f list =
    case list of
    [] -> [];
    listHead : listTail ->
        case f listHead of
        Nothing -> mapJust2 f listTail;
        Just v -> v : mapJust2 f listTail;
        ;
    ;

findOld :: (a -> Boolean) -> [a] -> Maybe a;
findOld predicate = Prelude.compose Prelude.listToMaybe (List.filter predicate);

findIndexOld :: (a -> Boolean) -> [a] -> Maybe Int;
findIndexOld predicate = Prelude.compose Prelude.listToMaybe (List.findIndices predicate);

data DeepSeqTestType =
    DeepSeqNested1
        type1 :: DeepSeqTestType
        type2 :: DeepSeqTestType |
    DeepSeqNested2
        type :: DeepSeqTestType
        string :: String |
    DeepSeqNested3
        string :: String
        type :: DeepSeqTestType |
    DeepSeqString string :: String
    ;

testDeepSeq =
    testDeepSeq1 == "a, b, c, d, e, f, g, h, i, j, k, l"
        && testDeepSeq2 == "a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x"
        && testDeepSeq3 == "a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x"
        && testDeepSeq4 == "a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x"
        && testDeepSeq5 == "a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x"
    || error "Error in M2.testDeepSeq"
    ;

private testDeepSeq1 =
    let
        accumulator = makeJStringAccumulator;

        dataInstance =
            DeepSeqNested1
                (DeepSeqNested3
                    (jStringAccumulator_AddString accumulator "a")
                    (DeepSeqNested2
                        (DeepSeqNested1
                            (DeepSeqString (jStringAccumulator_AddString accumulator "b"))
                            (DeepSeqString (jStringAccumulator_AddString accumulator "c"))
                        )
                        (jStringAccumulator_AddString accumulator "d")
                    )
                )
                (DeepSeqNested2
                    (DeepSeqNested3
                        (jStringAccumulator_AddString accumulator "e")
                        (DeepSeqNested1
                            (DeepSeqNested2
                                (DeepSeqNested1
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "f"))
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "g"))
                                )
                                (jStringAccumulator_AddString accumulator "h")
                            )
                            (DeepSeqNested2
                                (DeepSeqNested1
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "i"))
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "j"))
                                )
                                (jStringAccumulator_AddString accumulator "k")
                            )
                        )
                    )
                    (jStringAccumulator_AddString accumulator "l")
                )
            ;
    in
        Prelude.deepSeq dataInstance (jStringAccumulator_getStrings accumulator)
    ;

private testDeepSeq2 =
    let
        accumulator = makeJStringAccumulator;

        dataInstance =
            DeepSeqNested1
                (DeepSeqNested3
                    (jStringAccumulator_AddString accumulator "a")
                    (DeepSeqNested2
                        (DeepSeqNested1
                            (DeepSeqString (jStringAccumulator_AddString accumulator "b"))
                            (DeepSeqString (jStringAccumulator_AddString accumulator "c"))
                        )
                        (jStringAccumulator_AddString accumulator "d")
                    )
                )
                (DeepSeqNested2
                    (DeepSeqNested3
                        (jStringAccumulator_AddString accumulator "e")
                        (DeepSeqNested1
                            (DeepSeqNested2
                                (DeepSeqNested1
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "f"))
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "g"))
                                )
                                (jStringAccumulator_AddString accumulator "h")
                            )
                            (DeepSeqNested2
                                (DeepSeqNested1
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "i"))
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "j"))
                                )
                                (jStringAccumulator_AddString accumulator "k")
                            )
                        )
                    )
                    (jStringAccumulator_AddString accumulator "l")
                )
            ;

        dataInstance2 =
            DeepSeqNested1
                (DeepSeqNested3
                    (jStringAccumulator_AddString accumulator "m")
                    (DeepSeqNested2
                        (DeepSeqNested1
                            (DeepSeqString (jStringAccumulator_AddString accumulator "n"))
                            (DeepSeqString (jStringAccumulator_AddString accumulator "o"))
                        )
                        (jStringAccumulator_AddString accumulator "p")
                    )
                )
                (DeepSeqNested2
                    (DeepSeqNested3
                        (jStringAccumulator_AddString accumulator "q")
                        (DeepSeqNested1
                            (DeepSeqNested2
                                (DeepSeqNested1
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "r"))
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "s"))
                                )
                                (jStringAccumulator_AddString accumulator "t")
                            )
                            (DeepSeqNested2
                                (DeepSeqNested1
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "u"))
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "v"))
                                )
                                (jStringAccumulator_AddString accumulator "w")
                            )
                        )
                    )
                    (jStringAccumulator_AddString accumulator "x")
                )
            ;
    in
        Prelude.deepSeq (dataInstance, dataInstance2) (jStringAccumulator_getStrings accumulator)
    ;

private testDeepSeq3 =
    let
        accumulator = makeJStringAccumulator;

        dataInstance =
            DeepSeqNested1
                (DeepSeqNested3
                    (jStringAccumulator_AddString accumulator "a")
                    (DeepSeqNested2
                        (DeepSeqNested1
                            (DeepSeqString (jStringAccumulator_AddString accumulator "b"))
                            (DeepSeqString (jStringAccumulator_AddString accumulator "c"))
                        )
                        (jStringAccumulator_AddString accumulator "d")
                    )
                )
                (DeepSeqNested2
                    (DeepSeqNested3
                        (jStringAccumulator_AddString accumulator "e")
                        (DeepSeqNested1
                            (DeepSeqNested2
                                (DeepSeqNested1
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "f"))
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "g"))
                                )
                                (jStringAccumulator_AddString accumulator "h")
                            )
                            (DeepSeqNested2
                                (DeepSeqNested1
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "i"))
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "j"))
                                )
                                (jStringAccumulator_AddString accumulator "k")
                            )
                        )
                    )
                    (jStringAccumulator_AddString accumulator "l")
                )
            ;

        dataInstance2 =
            DeepSeqNested1
                (DeepSeqNested3
                    (jStringAccumulator_AddString accumulator "m")
                    (DeepSeqNested2
                        (DeepSeqNested1
                            (DeepSeqString (jStringAccumulator_AddString accumulator "n"))
                            (DeepSeqString (jStringAccumulator_AddString accumulator "o"))
                        )
                        (jStringAccumulator_AddString accumulator "p")
                    )
                )
                (DeepSeqNested2
                    (DeepSeqNested3
                        (jStringAccumulator_AddString accumulator "q")
                        (DeepSeqNested1
                            (DeepSeqNested2
                                (DeepSeqNested1
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "r"))
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "s"))
                                )
                                (jStringAccumulator_AddString accumulator "t")
                            )
                            (DeepSeqNested2
                                (DeepSeqNested1
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "u"))
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "v"))
                                )
                                (jStringAccumulator_AddString accumulator "w")
                            )
                        )
                    )
                    (jStringAccumulator_AddString accumulator "x")
                )
            ;
    in
        Prelude.deepSeq {#2 = dataInstance2, #1 = dataInstance} (jStringAccumulator_getStrings accumulator)
    ;

private testDeepSeq4 =
    let
        accumulator = makeJStringAccumulator;

        dataInstance =
            DeepSeqNested1
                (DeepSeqNested3
                    (jStringAccumulator_AddString accumulator "a")
                    (DeepSeqNested2
                        (DeepSeqNested1
                            (DeepSeqString (jStringAccumulator_AddString accumulator "b"))
                            (DeepSeqString (jStringAccumulator_AddString accumulator "c"))
                        )
                        (jStringAccumulator_AddString accumulator "d")
                    )
                )
                (DeepSeqNested2
                    (DeepSeqNested3
                        (jStringAccumulator_AddString accumulator "e")
                        (DeepSeqNested1
                            (DeepSeqNested2
                                (DeepSeqNested1
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "f"))
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "g"))
                                )
                                (jStringAccumulator_AddString accumulator "h")
                            )
                            (DeepSeqNested2
                                (DeepSeqNested1
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "i"))
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "j"))
                                )
                                (jStringAccumulator_AddString accumulator "k")
                            )
                        )
                    )
                    (jStringAccumulator_AddString accumulator "l")
                )
            ;

        dataInstance2 =
            DeepSeqNested1
                (DeepSeqNested3
                    (jStringAccumulator_AddString accumulator "m")
                    (DeepSeqNested2
                        (DeepSeqNested1
                            (DeepSeqString (jStringAccumulator_AddString accumulator "n"))
                            (DeepSeqString (jStringAccumulator_AddString accumulator "o"))
                        )
                        (jStringAccumulator_AddString accumulator "p")
                    )
                )
                (DeepSeqNested2
                    (DeepSeqNested3
                        (jStringAccumulator_AddString accumulator "q")
                        (DeepSeqNested1
                            (DeepSeqNested2
                                (DeepSeqNested1
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "r"))
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "s"))
                                )
                                (jStringAccumulator_AddString accumulator "t")
                            )
                            (DeepSeqNested2
                                (DeepSeqNested1
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "u"))
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "v"))
                                )
                                (jStringAccumulator_AddString accumulator "w")
                            )
                        )
                    )
                    (jStringAccumulator_AddString accumulator "x")
                )
            ;
    in
        Prelude.deepSeq {foo2 = dataInstance2, foo1 = dataInstance} (jStringAccumulator_getStrings accumulator)
    ;

private testDeepSeq5 =
    let
        accumulator = makeJStringAccumulator;

        dataInstance =
            DeepSeqNested1
                (DeepSeqNested3
                    (jStringAccumulator_AddString accumulator "a")
                    (DeepSeqNested2
                        (DeepSeqNested1
                            (DeepSeqString (jStringAccumulator_AddString accumulator "b"))
                            (DeepSeqString (jStringAccumulator_AddString accumulator "c"))
                        )
                        (jStringAccumulator_AddString accumulator "d")
                    )
                )
                (DeepSeqNested2
                    (DeepSeqNested3
                        (jStringAccumulator_AddString accumulator "e")
                        (DeepSeqNested1
                            (DeepSeqNested2
                                (DeepSeqNested1
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "f"))
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "g"))
                                )
                                (jStringAccumulator_AddString accumulator "h")
                            )
                            (DeepSeqNested2
                                (DeepSeqNested1
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "i"))
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "j"))
                                )
                                (jStringAccumulator_AddString accumulator "k")
                            )
                        )
                    )
                    (jStringAccumulator_AddString accumulator "l")
                )
            ;

        dataInstance2 =
            DeepSeqNested1
                (DeepSeqNested3
                    (jStringAccumulator_AddString accumulator "m")
                    (DeepSeqNested2
                        (DeepSeqNested1
                            (DeepSeqString (jStringAccumulator_AddString accumulator "n"))
                            (DeepSeqString (jStringAccumulator_AddString accumulator "o"))
                        )
                        (jStringAccumulator_AddString accumulator "p")
                    )
                )
                (DeepSeqNested2
                    (DeepSeqNested3
                        (jStringAccumulator_AddString accumulator "q")
                        (DeepSeqNested1
                            (DeepSeqNested2
                                (DeepSeqNested1
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "r"))
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "s"))
                                )
                                (jStringAccumulator_AddString accumulator "t")
                            )
                            (DeepSeqNested2
                                (DeepSeqNested1
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "u"))
                                    (DeepSeqString (jStringAccumulator_AddString accumulator "v"))
                                )
                                (jStringAccumulator_AddString accumulator "w")
                            )
                        )
                    )
                    (jStringAccumulator_AddString accumulator "x")
                )
            ;
    in
        Prelude.deepSeq {foo2 = dataInstance2, #1 = dataInstance} (jStringAccumulator_getStrings accumulator)
    ;

f1 :: Prelude.Integer -> Prelude.Integer;
f1 !x =
    if x < 2 then
        1
    else
        x * f1 (x - 1)
    ;

f2 :: Prelude.Integer -> Prelude.Integer;
f2 !x =
    if x < 2 then
        1
    else
        f2 (x - 1) * x
    ;

data private DCArgNameTestType =
    DCArgNameTestTypeDC1
        #1 :: Int
        #2 :: Double |
    DCArgNameTestTypeDC2
        #3 :: Int
        #2 :: Double |
    DCArgNameTestTypeDC3
        arg1 :: Int
        arg2 :: Double |
    DCArgNameTestTypeDC4
        arg1 :: Int
        #1 :: Double
        arg2 :: Double |
    DCArgNameTestTypeDC99
    deriving Eq, Ord
    ;

data private M2Map k a =
    private Tip |
    private Bin
        size :: !Int
        key :: !k
        value :: a
        leftMap :: !(M2Map k a)
        rightMap :: !(M2Map k a)
    ;

m2MapIsEmpty1 :: M2Map k a -> Boolean;
m2MapIsEmpty1 !t =
    case t of
    Tip -> True;
    Bin sz k x l r -> False;
    ;

m2MapIsEmpty2 :: M2Map k a -> Boolean;
m2MapIsEmpty2 !t =
    case t of
    Tip -> True;
    Bin {} -> False;
    ;

m2MapSize1 :: M2Map k a -> Int;
m2MapSize1 !t =
    case t of
    Tip -> 0;
    Bin sz k x l r -> sz;
    ;

m2MapSize2 :: M2Map k a -> Int;
m2MapSize2 !t =
    case t of
    Tip -> 0;
    Bin {size = sz} -> sz;
    ;

m2MapSize3 :: M2Map k a -> Int;
m2MapSize3 !t =
    case t of
    Tip -> 0;
    Bin {size} -> size;
    ;

m2MapLookup1 :: Ord k => k -> M2Map k a -> Maybe a;
m2MapLookup1 !k !t =
    case t of
    Tip -> Nothing;
    Bin sz kx x l r ->
        case compare k kx of
        LT -> m2MapLookup1 k l;
        GT -> m2MapLookup1 k r;
        EQ -> Just x;
        ;
    ;

m2MapLookup2 :: Ord k => k -> M2Map k a -> Maybe a;
m2MapLookup2 !k !t =
    case t of
    Tip -> Nothing;
    Bin {leftMap, rightMap, key, value} ->
        case compare k key of
        LT -> m2MapLookup2 k leftMap;
        GT -> m2MapLookup2 k rightMap;
        EQ -> Just value;
        ;
    ;

m2MapTest1 :: M2Map k a -> Maybe Int;
m2MapTest1 !t =
    case t of
    Tip -> Nothing;
    Bin {leftMap = l, rightMap = _, size = _, key} -> Nothing;
    ;

data private M2TestData a b =
    private M2TestDataCons1
        #1 :: a
        #2 :: b |
    private M2TestDataCons2
        #1 :: b
        #2 :: a
    ;

m2DCArgTest1 :: M2TestData Boolean Int -> Boolean;
m2DCArgTest1 !t =
    case t of
    M2TestDataCons1 {#1 = numOne} -> numOne;
    M2TestDataCons2 {#1} -> True;
    ;

m2DCArgTest2 :: M2TestData Boolean Int -> Boolean;
m2DCArgTest2 !t =
    case t of
    M2TestDataCons1 {#1 = numOne} -> numOne;
    M2TestDataCons2 {#1} -> True;
    ;

m2DCArgTestFoo :: Prelude.Either Boolean Boolean -> Boolean;
m2DCArgTestFoo !t =
    case t of
    Prelude.Right a -> a;
    _ -> False;
    ;

data private M2TestData2 a b =
    private M2TestData2Cons1
        #1 :: a
        field1 :: b
        field1_1 :: b
    ;

testNamedDataConstructors :: Boolean;
testNamedDataConstructors =
    testNamedDCs1
        && testNamedDCs2
        && testNamedDCs3
        && testStrictNamedDCSelection
        && testStrictNamedDCSelection2
        && testLazyNamedDCSelection
        && testTopLevelNamedDCSelection
        && testNamedDCSelection
        && testNamedDCSelection2
        && testNamedDCSelection3
        && testNamedDCSelection4
    || error "M2.testNamedDataConstructors failed."
    ;

testNamedDCs1 = equals [1.0].Cons.head 1.0;

testNamedDCs2 = equals [1.0].Prelude.Cons.tail [];

testNamedDCs3 = equals [1.0, 2.0, 3.0, 4.0, 5.0].Cons.tail.Cons.tail.Cons.tail.Cons.tail.Cons.head 5.0;

lazyId x = x;

testLazyNamedDCSelectionHelper = lazyId [1.0].Cons.head;

testLazyNamedDCSelection = testLazyNamedDCSelectionHelper == 1.0;

strictId !x = x;

testStrictNamedDCSelectionHelper = strictId [1.0].Cons.head;

testStrictNamedDCSelection = testStrictNamedDCSelectionHelper == 1.0;

prependANum x =
    if head x > 5.0 then
        4 : x
    else
        1 : x
    ;

testStrictNamedDCSelection2Helper =
    let
        someNumber = 1.0 + 2.0;

        list = [someNumber];

        list2 = prependANum list;
    in
        list2.Cons.tail.Cons.head
    ;

testStrictNamedDCSelection2 = testStrictNamedDCSelection2Helper == 3.0;

testTopLevelNamedDCSelectionHelper = [2.0].Cons.head;

testTopLevelNamedDCSelection = testTopLevelNamedDCSelectionHelper == 2.0;

testNamedDCSelection =
    let
        dcValue = [1.2, 2.3, 3.4];
    in
        dcValue.Cons.head + dcValue.Cons.tail.Cons.head == 3.5
    ;

testNamedDCSelection2 =
    let
        dcValue = [1.2, 2.3, 3.4];

        dcValueHead = dcValue.Cons.head;

        dcValueTailHead = dcValue.Cons.tail.Cons.head;
    in
        dcValueHead + dcValueTailHead == 3.5
    ;

testNamedDCSelection3 =
    let
        a = Just 2.0;

        b = Just 3.0;
    in
        case a of
        Just {value} -> value != b.Just.value;
    ;

data private M2TestData3 a b c =
    private M2TestData3Cons1
        #1 :: a
        #2 :: b
        field1 :: c
    ;

testNamedDCSelection4 = (M2TestData3Cons1 2.0 "foo" Nothing).M2TestData3Cons1.#1 == 2.0;

public selectDCFieldShouldFail = ([] :: [Prelude.Double]).Cons.head;

/**
 * A test type with only one data constructor wrapping an int. The single data constructor case is handled more efficiently in
 * lecc that the general case.
 */
data private M2TestDataSingleDCIntWrapper =
    private M2TestDataSingleDCIntWrapper wrappedInt :: Int
    ;

/**
 * A test type with two data constructors wrapping an int. The single data constructor case is handled more efficiently in lecc
 * that the general case.
 */
data private M2TestDataTwoDCIntWrapper =
    private M2TestDataTwoDCIntWrapper1 wrappedInt :: Int |
    private M2TestDataTwoDCIntWrapper2 wrappedInt :: Int
    ;

/**
 * A test type with thirty-five data constructors wrapping an int. In lecc, case expressions are handled with a java switch
 * statement, whose efficiency depends on the number of cases.
 */
data private M2TestDataBigDCIntWrapper =
    private M2TestDataBigDCIntWrapper1 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper2 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper3 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper4 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper5 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper6 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper7 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper8 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper9 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper10 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper11 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper12 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper13 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper14 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper15 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper16 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper17 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper18 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper19 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper20 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper21 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper22 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper23 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper24 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper25 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper26 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper27 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper28 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper29 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper30 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper31 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper32 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper33 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper34 wrappedInt :: Int |
    private M2TestDataBigDCIntWrapper35 wrappedInt :: Int
    ;

bigWrappedSingleDCIntList :: Int -> [M2TestDataSingleDCIntWrapper];
bigWrappedSingleDCIntList !n =
    let
        dataHelper !i =
            if i == n then
                []
            else
                M2TestDataSingleDCIntWrapper 1 : dataHelper (i + 1)
            ;
    in
        dataHelper 0
    ;

bigWrappedTwoDCIntList :: Int -> [M2TestDataTwoDCIntWrapper];
bigWrappedTwoDCIntList !n =
    let
        dataHelper !i =
            if i == n then
                []
            else
                M2TestDataTwoDCIntWrapper1 1 : dataHelper (i + 1)
            ;
    in
        dataHelper 0
    ;

bigWrappedBigDCIntList :: Int -> [M2TestDataBigDCIntWrapper];
bigWrappedBigDCIntList !n =
    let
        dataHelper !i =
            if i == n then
                []
            else
                M2TestDataBigDCIntWrapper1 1 : dataHelper (i + 1)
            ;
    in
        dataHelper 0
    ;

getWrappedIntFromSingleDCIntWrapper_select :: M2TestDataSingleDCIntWrapper -> Int;
getWrappedIntFromSingleDCIntWrapper_select !x = x.M2TestDataSingleDCIntWrapper.wrappedInt;

getWrappedIntFromSingleDCIntWrapper_case :: M2TestDataSingleDCIntWrapper -> Int;
getWrappedIntFromSingleDCIntWrapper_case !x =
    case x of
    M2TestDataSingleDCIntWrapper wrappedInt -> wrappedInt;
    ;

getWrappedIntFromTwoDCIntWrapper_select :: M2TestDataTwoDCIntWrapper -> Int;
getWrappedIntFromTwoDCIntWrapper_select !x = x.M2TestDataTwoDCIntWrapper1.wrappedInt;

getWrappedIntFromTwoDCIntWrapper_case :: M2TestDataTwoDCIntWrapper -> Int;
getWrappedIntFromTwoDCIntWrapper_case !x =
    case x of
    M2TestDataTwoDCIntWrapper1 wrappedInt -> wrappedInt;
    ;

getWrappedIntFromBigDCIntWrapper_select :: M2TestDataBigDCIntWrapper -> Int;
getWrappedIntFromBigDCIntWrapper_select !x = x.M2TestDataBigDCIntWrapper1.wrappedInt;

getWrappedIntFromBigDCIntWrapper_case :: M2TestDataBigDCIntWrapper -> Int;
getWrappedIntFromBigDCIntWrapper_case !x =
    case x of
    M2TestDataBigDCIntWrapper1 wrappedInt -> wrappedInt;
    ;

selectSumSingleDC :: Int -> Int;
selectSumSingleDC !n = sum (map getWrappedIntFromSingleDCIntWrapper_select (bigWrappedSingleDCIntList n));

caseSumSingleDC :: Int -> Int;
caseSumSingleDC !n = sum (map getWrappedIntFromSingleDCIntWrapper_case (bigWrappedSingleDCIntList n));

selectSumTwoDC :: Int -> Int;
selectSumTwoDC !n = sum (map getWrappedIntFromTwoDCIntWrapper_select (bigWrappedTwoDCIntList n));

caseSumTwoDC :: Int -> Int;
caseSumTwoDC !n = sum (map getWrappedIntFromTwoDCIntWrapper_case (bigWrappedTwoDCIntList n));

selectSumBigDC :: Int -> Int;
selectSumBigDC !n = sum (map getWrappedIntFromBigDCIntWrapper_select (bigWrappedBigDCIntList n));

caseSumBigDC :: Int -> Int;
caseSumBigDC !n = sum (map getWrappedIntFromBigDCIntWrapper_case (bigWrappedBigDCIntList n));

/**
 * A test type with only one data constructor wrapping a function.
 *
 * f !x = x.Just.value 2.0 is equivalent to f !x = (case x of Just value -> value;) 2.0; which appears different from f !x = case
 * x of Just value -> value 2.0;;
 *
 * in that the selection is applied to the value 2.0.
 */
data private M2TestDataSingleDCFnWrapper =
    private M2TestDataSingleDCFnWrapper wrappedFn :: (Int -> Int)
    ;

bigWrappedSingleDCFnList :: Int -> [M2TestDataSingleDCFnWrapper];
bigWrappedSingleDCFnList !n =
    let
        wrappedFn !x = x + (1 :: Int);

        dataHelper !i =
            if i == n then
                []
            else
                M2TestDataSingleDCFnWrapper wrappedFn : dataHelper (i + 1)
            ;
    in
        dataHelper 0
    ;

applySingleDCFnWrapperFnCase !x =
    case x of
    M2TestDataSingleDCFnWrapper wrappedFn -> wrappedFn (2 :: Int);
    ;

applySingleDCFnWrapperFnSelect !x = x.M2TestDataSingleDCFnWrapper.wrappedFn (2 :: Int);

selectSumSingleDC2 :: Int -> Int;
selectSumSingleDC2 !n = sum (map applySingleDCFnWrapperFnCase (bigWrappedSingleDCFnList n));

caseSumSingleDC2 :: Int -> Int;
caseSumSingleDC2 !n = sum (map applySingleDCFnWrapperFnCase (bigWrappedSingleDCFnList n));

data M2TestDataSingleDCFnWrapper2 =
    M2TestDataSingleDCFnWrapper2 wrappedFn :: (Double -> Double)
    ;

makeM2TestDataSingleDCFnWrapper2 = M2TestDataSingleDCFnWrapper2 (add 1.0);

fdcFn :: M2TestDataSingleDCFnWrapper2 -> Double -> Double;
fdcFn fdc dbl = fdc.M2TestDataSingleDCFnWrapper2.wrappedFn dbl;

fdcFn2 :: M2TestDataSingleDCFnWrapper2 -> Double -> Double;
fdcFn2 fdc dbl =
    case fdc of
    M2TestDataSingleDCFnWrapper2 wrappedFn -> wrappedFn dbl;
    ;

fdcTest1 :: Int -> Double;
fdcTest1 x = List.sum (map (fdcFn makeM2TestDataSingleDCFnWrapper2) (take x (repeat 1.0)));

fdcTest2 :: Int -> Double;
fdcTest2 x = List.sum (map (fdcFn2 makeM2TestDataSingleDCFnWrapper2) (take x (repeat 1.0)));

data private M2PatGroupTestData a b c =
    private M2PatGroupTestDataCons1
        #1 :: a
        #2 :: b
        field1 :: c |
    private M2PatGroupTestDataCons2
        #1 :: a
        #2 :: b |
    private M2PatGroupTestDataCons3
        #1 :: a
        aField :: c |
    private M2PatGroupTestDataCons4 aField :: c
    ;

patGroupTest1 :: M2PatGroupTestData a b c -> Boolean;
private patGroupTest1 x =
    case x of
    (M2PatGroupTestDataCons1 | M2PatGroupTestDataCons4) {} -> True;
    _ -> False;
    ;

patGroupTest2 :: M2PatGroupTestData Boolean b c -> Boolean;
private patGroupTest2 x =
    case x of
    (M2PatGroupTestDataCons2 | M2PatGroupTestDataCons3) someField _ -> someField;
    _ -> False;
    ;

patGroupTest3 :: M2PatGroupTestData a b Double -> Double;
private patGroupTest3 x =
    case x of
    (M2PatGroupTestDataCons3 | M2PatGroupTestDataCons4) {aField} -> aField;
    _ -> -1.876;
    ;

patGroupTest4 :: M2PatGroupTestData a b Double -> Double;
private patGroupTest4 x =
    case x of
    M2PatGroupTestDataCons3 {aField} -> aField;
    _ -> -1.876;
    ;

testIntCaseHelper x =
    case x of
    -1 -> "-1";
    0 -> "0";
    1 -> "1";
    (2 | 3) -> "2 or 3";
    _ -> "Something else";
    ;

isMinusOne x =
    case x of
    -1 -> True;
    _ -> False;
    ;

isZero_1 x =
    case x of
    0 -> True;
    _ -> False;
    ;

isZero_2 x =
    case x of
    0 -> True;
    _ -> False;
    ;

isOne x =
    case x of
    1 -> True;
    _ -> False;
    ;

testLazyCaseOnIntHelper =
    lazyId
        (
            case 98 + 1 of
            99 -> 1.0;
            _ -> 2.0;
        )
    ;

testStrictCaseOnIntHelper =
    strictId
        (
            case 97 + 2 of
            99 -> 1.0;
            _ -> 2.0;
        )
    ;

testIntCase =
    assert (testLazyCaseOnIntHelper == 1.0)
    && assert (testStrictCaseOnIntHelper == 1.0)
    && assert (isMinusOne (-1))
    && assert (isZero_1 0)
    && assert (isZero_2 0)
    && assert (isOne 1)
    && assert
        (equals
            (map testIntCaseHelper [-1, -0, 0, 1, 2, 3, 4, 5, 129873129319287391871239])
            ["-1", "0", "0", "1", "2 or 3", "2 or 3", "Something else", "Something else", "Something else"]
        )
    ;

testCharCaseHelper x =
    case x of
    ('a' | 'c' | 'e' | '\ucafe' | '\ubabe' | '$' | '\'' | '\n') -> True;
    '\\' -> True;
    _ -> False;
    ;

isPercent1 x =
    case x of
    '%' -> True;
    _ -> False;
    ;

isPercent2 x =
    case x of
    '%' -> True;
    _ -> False;
    ;

isPercent3 x =
    case x of
    '%' -> True;
    _ -> False;
    ;

testLazyCaseOnCharHelper =
    lazyId
        (
            case 'a' of
            'a' -> 1.0;
            _ -> 2.0;
        )
    ;

testStrictCaseOnCharHelper =
    strictId
        (
            case 'a' of
            'a' -> 1.0;
            _ -> 2.0;
        )
    ;

testCharCase =
    assert (testLazyCaseOnCharHelper == 1.0)
    && assert (testStrictCaseOnCharHelper == 1.0)
    && assert (isPercent1 '%')
    && assert (isPercent2 '%')
    && assert (isPercent3 '%')
    && assert
        (equals
            (map testCharCaseHelper (Prelude.append (toList "abcdefg") ['\u1234', '\ucafe', '\\', '\f', '\n', '%', '$']))
            (Prelude.append [True, False, True, False, True, False, False] [False, True, True, False, True, False, True])
        )
    ;

nextNPrimes :: [Int] -> Int -> {nextNPrimes :: [Int], remainingPrimes :: [Int]};
nextNPrimes remainingPrimes nPrimesToTake =
    let
        pair = List.splitAt nPrimesToTake remainingPrimes;
    in
        {nextNPrimes = pair.#1, remainingPrimes = pair.#2}
    ;

allPrimesExternal :: CalValue;
allPrimesExternal = unsafeCoerce M1.allPrimes;

nextNPrimesExternal :: CalValue -> Int -> {nextNPrimes :: [Int], remainingPrimes :: CalValue};
nextNPrimesExternal remainingPrimesAsInternal nPrimesToTake =
    unsafeCoerce (nextNPrimes (unsafeCoerce remainingPrimesAsInternal) nPrimesToTake);

takeN :: [a] -> Int -> ([a], [a]);
takeN list nToTake = List.splitAt nToTake list;

takeNExternal :: Outputable a => CalValue -> Int -> ([a], CalValue);
takeNExternal list nToTake = unsafeCoerce (takeN (unsafeCoerce list) nToTake);

takeNExternal_ListOfInt :: CalValue -> Int -> ([Int], CalValue);
takeNExternal_ListOfInt list nToTake = takeNExternal list nToTake;

stringList :: [String];
stringList =
    List.cycle
        (List.sort
            ["Anton", "Linda", "Pat", "Yves", "Michael", "Andy", "Fred", "Frank", "Helen", "Sammy", "Sara", "Alexander"]
        )
    ;

stringListExternal :: CalValue;
stringListExternal = unsafeCoerce stringList;

takeNExternal_ListOfString :: CalValue -> Int -> ([String], CalValue);
takeNExternal_ListOfString list nToTake = takeNExternal list nToTake;

allPrimesAdjunct :: Prelude.JObject;
allPrimesAdjunct = (\x -> Prelude.output (Prelude.unsafeCoerce x :: Prelude.CalValue)) M1.allPrimes;

takeNIntAdjunct :: Prelude.JObject -> Prelude.JObject -> Prelude.JObject;
takeNIntAdjunct list nToTake =
    (\x -> Prelude.output (Prelude.unsafeCoerce x :: ([Int], CalValue)))
        (takeN
            ((\x -> Prelude.unsafeCoerce (Prelude.input x :: Prelude.CalValue) :: [Prelude.Int]) list)
            ((Prelude.input :: Prelude.JObject -> Prelude.Int) nToTake)
        )
    ;

data foreign unsafe import jvm private "java.lang.String"
    private ForeignString deriving Inputable, Outputable, Eq, Ord, Debug.Show;

foreign unsafe import jvm "constructor" private new_ForeignString :: String -> ForeignString;

testDerivedForeignInstances =
    let
        a = new_ForeignString "aaaa";

        b = new_ForeignString "bbbb";
    in
        a == a
            && a != b
            && a < b
            && b > a
            && a <= a
            && a <= b
            && b >= b
            && b >= a
            && compare a b == LT
            && compare b a == GT
            && compare a a == EQ
            && max a b == b
            && min a b == a
            && not (a == b)
            && not (a != a)
            && not (b < a)
            && not (a > b)
            && not (b <= a)
            && not (a >= b)
            && Debug.show a == "aaaa"
            && Debug.show b == "bbbb"
            && input (output a) == a
        || error "M2.testDerivedForeignInstances failed!"
    ;

data foreign unsafe import jvm private "int" private ForeignInt deriving Inputable, Outputable, Eq, Debug.Show, Ord;

makeForeignInt :: Int -> ForeignInt;
makeForeignInt !x = unsafeCoerce x;

data foreign unsafe import jvm private "byte" private ForeignByte deriving Inputable, Outputable, Eq, Debug.Show, Ord;

makeForeignByte :: Byte -> ForeignByte;
makeForeignByte !x = unsafeCoerce x;

data foreign unsafe import jvm private "short" private ForeignShort deriving Inputable, Outputable, Eq, Debug.Show, Ord;

makeForeignShort :: Short -> ForeignShort;
makeForeignShort !x = unsafeCoerce x;

data foreign unsafe import jvm private "long" private ForeignLong deriving Inputable, Outputable, Eq, Debug.Show, Ord;

makeForeignLong :: Long -> ForeignLong;
makeForeignLong !x = unsafeCoerce x;

data foreign unsafe import jvm private "float" private ForeignFloat deriving Inputable, Outputable, Eq, Debug.Show, Ord;

makeForeignFloat :: Float -> ForeignFloat;
makeForeignFloat !x = unsafeCoerce x;

data foreign unsafe import jvm private "double" private ForeignDouble deriving Inputable, Outputable, Eq, Debug.Show, Ord;

makeForeignDouble :: Double -> ForeignDouble;
makeForeignDouble !x = unsafeCoerce x;

data foreign unsafe import jvm private "boolean" private ForeignBoolean deriving Inputable, Outputable, Eq, Debug.Show, Ord;

makeForeignBoolean :: Boolean -> ForeignBoolean;
makeForeignBoolean !x = unsafeCoerce x;

data foreign unsafe import jvm private "char" private ForeignChar deriving Inputable, Outputable, Eq, Debug.Show, Ord;

makeForeignChar :: Char -> ForeignChar;
makeForeignChar !x = unsafeCoerce x;

testDerivedForeignPrimitiveInstances =
    assert (makeForeignBoolean True == makeForeignBoolean True)
        && assert (makeForeignChar 'c' == makeForeignChar 'c')
        && assert (makeForeignByte 10 == makeForeignByte 10)
        && assert (makeForeignShort 10 == makeForeignShort 10)
        && assert (makeForeignInt 10 == makeForeignInt 10)
        && assert (makeForeignLong 10 == makeForeignLong 10)
        && assert (makeForeignFloat 10 == makeForeignFloat 10)
        && assert (makeForeignDouble 10.0 == makeForeignDouble 10.0)
        && assert (makeForeignBoolean False != makeForeignBoolean True)
        && assert (makeForeignChar 'b' != makeForeignChar 'c')
        && assert (makeForeignByte 9 != makeForeignByte 10)
        && assert (makeForeignShort 9 != makeForeignShort 10)
        && assert (makeForeignInt 9 != makeForeignInt 10)
        && assert (makeForeignLong 9 != makeForeignLong 10)
        && assert (makeForeignFloat 9 != makeForeignFloat 10)
        && assert (makeForeignDouble 9.0 != makeForeignDouble 10.0)
        && assert (makeForeignBoolean False < makeForeignBoolean True)
        && assert (makeForeignChar 'b' < makeForeignChar 'c')
        && assert (makeForeignByte 9 < makeForeignByte 10)
        && assert (makeForeignShort 9 < makeForeignShort 10)
        && assert (makeForeignInt 9 < makeForeignInt 10)
        && assert (makeForeignLong 9 < makeForeignLong 10)
        && assert (makeForeignFloat 9 < makeForeignFloat 10)
        && assert (makeForeignDouble 9.0 < makeForeignDouble 10.0)
        && assert (makeForeignBoolean False <= makeForeignBoolean True)
        && assert (makeForeignChar 'b' <= makeForeignChar 'c')
        && assert (makeForeignByte 9 <= makeForeignByte 10)
        && assert (makeForeignShort 9 <= makeForeignShort 10)
        && assert (makeForeignInt 9 <= makeForeignInt 10)
        && assert (makeForeignLong 9 <= makeForeignLong 10)
        && assert (makeForeignFloat 9 <= makeForeignFloat 10)
        && assert (makeForeignDouble 9.0 <= makeForeignDouble 10.0)
        && assert (makeForeignBoolean True >= makeForeignBoolean False)
        && assert (makeForeignChar 'd' >= makeForeignChar 'c')
        && assert (makeForeignByte 11 >= makeForeignByte 10)
        && assert (makeForeignShort 11 >= makeForeignShort 10)
        && assert (makeForeignInt 11 >= makeForeignInt 10)
        && assert (makeForeignLong 11 >= makeForeignLong 10)
        && assert (makeForeignFloat 11 >= makeForeignFloat 10)
        && assert (makeForeignDouble 11.0 >= makeForeignDouble 10.0)
        && assert (makeForeignBoolean True > makeForeignBoolean False)
        && assert (makeForeignChar 'd' > makeForeignChar 'c')
        && assert (makeForeignByte 11 > makeForeignByte 10)
        && assert (makeForeignShort 11 > makeForeignShort 10)
        && assert (makeForeignInt 11 > makeForeignInt 10)
        && assert (makeForeignLong 11 > makeForeignLong 10)
        && assert (makeForeignFloat 11 > makeForeignFloat 10)
        && assert (makeForeignDouble 11.0 > makeForeignDouble 10.0)
        && assert (compare (makeForeignBoolean True) (makeForeignBoolean False) == GT)
        && assert (compare (makeForeignChar 'd') (makeForeignChar 'c') == GT)
        && assert (compare (makeForeignByte 11) (makeForeignByte 10) == GT)
        && assert (compare (makeForeignShort 11) (makeForeignShort 10) == GT)
        && assert (compare (makeForeignInt 11) (makeForeignInt 10) == GT)
        && assert (compare (makeForeignLong 11) (makeForeignLong 10) == GT)
        && assert (compare (makeForeignFloat 11) (makeForeignFloat 10) == GT)
        && assert (compare (makeForeignDouble 11.0) (makeForeignDouble 10.0) == GT)
        && assert (min (makeForeignBoolean True) (makeForeignBoolean False) == makeForeignBoolean False)
        && assert (min (makeForeignChar 'd') (makeForeignChar 'c') == makeForeignChar 'c')
        && assert (min (makeForeignByte 11) (makeForeignByte 10) == makeForeignByte 10)
        && assert (min (makeForeignShort 11) (makeForeignShort 10) == makeForeignShort 10)
        && assert (min (makeForeignInt 11) (makeForeignInt 10) == makeForeignInt 10)
        && assert (min (makeForeignLong 11) (makeForeignLong 10) == makeForeignLong 10)
        && assert (min (makeForeignFloat 11) (makeForeignFloat 10) == makeForeignFloat 10)
        && assert (min (makeForeignDouble 11.0) (makeForeignDouble 10.0) == makeForeignDouble 10.0)
        && assert (max (makeForeignBoolean True) (makeForeignBoolean False) == makeForeignBoolean True)
        && assert (max (makeForeignChar 'd') (makeForeignChar 'c') == makeForeignChar 'd')
        && assert (max (makeForeignByte 11) (makeForeignByte 10) == makeForeignByte 11)
        && assert (max (makeForeignShort 11) (makeForeignShort 10) == makeForeignShort 11)
        && assert (max (makeForeignInt 11) (makeForeignInt 10) == makeForeignInt 11)
        && assert (max (makeForeignLong 11) (makeForeignLong 10) == makeForeignLong 11)
        && assert (max (makeForeignFloat 11) (makeForeignFloat 10) == makeForeignFloat 11)
        && assert (max (makeForeignDouble 11.0) (makeForeignDouble 10.0) == makeForeignDouble 11.0)
        && assert (Debug.show (makeForeignBoolean True) == "true")
        && assert (Debug.show (makeForeignChar 'c') == "c")
        && assert (Debug.show (makeForeignByte 12) == "12")
        && assert (Debug.show (makeForeignShort 12) == "12")
        && assert (Debug.show (makeForeignInt 12) == "12")
        && assert (Debug.show (makeForeignLong 12) == "12")
        && assert (Debug.show (makeForeignFloat 12) == "12.0")
        && assert (Debug.show (makeForeignDouble 12) == "12.0")
    || error "M2.testDerivedForeignPrimitiveInstances failed"
    ;

trctester = trc trctester;

trc :: [Prelude.Double] -> [Prelude.Double];
trc list =
    case list of
    x : xs -> trc xs;
    [] -> [0.0];
    ;

testTailRecursiveVarInlining :: Prelude.Boolean -> Prelude.Boolean -> Prelude.Double -> Prelude.Double -> Prelude.Double;
testTailRecursiveVarInlining a b c d =
    let
        v1 = testTailRecursiveVarInlining Prelude.False Prelude.False 2.0 3.0;

        v2 =
            if a then
                testTailRecursiveVarInlining Prelude.False Prelude.False 2.0 4.0
            else
                2.0
            ;
    in
        if a then
            v1
        else if b then
            v2
        else
            1.0
    ;

data private EnumButNotOrd =
    EBNO1 |
    EBNO2 |
    EBNO3 |
    EBNO4 |
    EBNO5
    deriving Enum
    ;

private equalsEBNO !x !y =
    case x of
    EBNO1 ->
        case y of
        EBNO1 -> True;
        _ -> False;
        ;
    EBNO2 ->
        case y of
        EBNO2 -> True;
        _ -> False;
        ;
    EBNO3 ->
        case y of
        EBNO3 -> True;
        _ -> False;
        ;
    EBNO4 ->
        case y of
        EBNO4 -> True;
        _ -> False;
        ;
    EBNO5 ->
        case y of
        EBNO5 -> True;
        _ -> False;
        ;
    ;

equalsEBNOList !x !y =
    case x of
    [] ->
        case y of
        [] -> True;
        _ -> False;
        ;
    firstX : restX ->
        case y of
        [] -> False;
        firstY : restY ->
            if equalsEBNO firstX firstY then
                equalsEBNOList restX restY
            else
                False
            ;
        ;
    ;

testDerivedEnumIndependence =
    Prelude.upFrom EBNO3 `equalsEBNOList` [EBNO3, EBNO4, EBNO5]
        && Prelude.upFromTo EBNO1 EBNO2 `equalsEBNOList` [EBNO1, EBNO2]
        && Prelude.upFromThen EBNO1 EBNO3 `equalsEBNOList` [EBNO1, EBNO3, EBNO5]
        && take 3 (Prelude.upFromThenTo EBNO2 EBNO2 EBNO3) `equalsEBNOList` [EBNO2, EBNO2, EBNO2]
        && Prelude.upFromThenTo EBNO1 EBNO2 EBNO4 `equalsEBNOList` [EBNO1, EBNO2, EBNO3, EBNO4]
    || error "M2.testDerivedEnumIndependence failed"
    ;

testLiftedExpressionsHelper x y =
    if x then
        y
    else
        y
    ;

testLiftedExpressions x =
    Prelude.seq
        (testLiftedExpressionsHelper
            Prelude.True
            (
                if x then
                    Prelude.output {x = 1.0}
                else
                    Prelude.output {y = 2.0}
            )
        )
        True
    ;

data private Numeric =
    NumericOne |
    NumericTwo |
    NumericThree |
    NumericFour
    deriving Prelude.Enum, Prelude.IntEnum, Prelude.Outputable, Prelude.Eq
    ;

testDerivedIntEnumInstances =
    assert (Prelude.enumToInt NumericOne == 0)
    && assert (Prelude.enumToInt NumericTwo == 1)
    && assert (Prelude.enumToInt NumericThree == 2)
    && assert (Prelude.enumToInt NumericFour == 3)
    && assert (Prelude.intToEnum 0 == NumericOne)
    && assert (Prelude.intToEnum 1 == NumericTwo)
    && assert (Prelude.intToEnum 2 == NumericThree)
    && assert (Prelude.intToEnum 3 == NumericFour)
    && assert (Prelude.intToEnumChecked (-2) == (Nothing :: Maybe Numeric))
    && assert (Prelude.intToEnumChecked 2 == Just NumericThree)
    && assert (Prelude.intToEnumChecked 50 == (Nothing :: Maybe Numeric))
    ;

private mutualA =
    let
        /**
         * @arg x
         * @arg y
         */
        b = mutualB;
    in
        b
    ;

private mutualB x =
    let
        /**
         * @arg x
         * @arg y
         */
        a = mutualA;
    in
        (\q -> Prelude.id (\y -> a q y)) x
    ;

data foreign unsafe import jvm "java.lang.Boolean" JBoolean;

foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.M2.BoolTest.nullBoolean"
    private nullJBoolean :: JBoolean;

foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.M2.BoolTest.trueBoolean"
    private trueJBoolean :: JBoolean;

foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.M2.BoolTest.falseBoolean"
    private falseJBoolean :: JBoolean;

foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.M2.BoolTest.typeOfBoolean"
    private typeOfJBoolean :: JBoolean -> String;

testMarshallingJBoolean =
    typeOfJBoolean nullJBoolean == "null" && typeOfJBoolean trueJBoolean == "true" && typeOfJBoolean falseJBoolean == "false"
    || Prelude.error "bad marshalling"
    ;

lengthExamples =
    assert (length [] == 0)
    && assert (length [1, 2, 10.0] == 3)
    && assert (length [True, False] == 1)
    && assert (length [[[]]] == 1)
    ;

caseExample =
    case Just (Just 'a') of
    Just x ->
        case x of
        Nothing -> "Zaphod";
        ;
    ;

seqExample1 = seq (trace "should trace" 1.0 + 2.0) True;

seqExample2 = seq [trace "should not trace" 1.0 + 2.0] True;

seqExample3 =
    let
        x =
            {
                name = trace "a" "Kermit",
                ageOfFriends = [trace "b" 10.0, trace "c" 5.0],
                frog = trace "d" True,
                zFactor = 23.0
            }
            ;
    in
        seq x x.zFactor
    ;

deepSeqExample1 = deepSeq [trace "should trace" 1.0 + 2.0] True;

deepSeqExample2 =
    let
        x =
            {
                name = trace "a" "Kermit",
                ageOfFriends = [trace "b" 10.0, trace "c" 5.0],
                frog = trace "d" True,
                zFactor = 23.0
            }
            ;
    in
        deepSeq x x.zFactor
    ;

/**
 * Traverses a value and gathers leaf values of type Double within the value into a list. The value is assumed to be built out of
 * list and records (to arbitrary levels of nesting and recursion), with various terminal types. The leaf values that are of type
 * Double are gathered.
 */

gatherDoubleValues :: Typeable a => a -> [Double];
gatherDoubleValues value = gatherDoubleValues2 (toDynamic value);

gatherDoubleValues2 :: Dynamic -> [Double];
gatherDoubleValues2 value =
    let
        typeOfValue = dynamicUnderlyingType value;
    in
        if isDoubleType typeOfValue then
            [fromJust (fromDynamic value)]
        else if isListType typeOfValue then
            concatMap gatherDoubleValues2 (fromJust (fromDynamicList value))
        else if isRecordType typeOfValue then
            concatMap gatherDoubleValues2 (fromJust (dynamicRecordFieldValues value))
        else
            []
    ;

gatherDoubleValuesExamples =
    assert (gatherDoubleValues (1 + 2.0) == [3])
    && assert (gatherDoubleValues [10, 20, 4.0] == [10, 20, 4.0])
    && assert
        (
            gatherDoubleValues
                [
                    {name = "Anton", age = 1.9, favoriteNumbers = [1.0, 2.0, 3.0], isCanadian = True},
                    {name = "Archimedes", age = 2500, favoriteNumbers = [Math.pi, 0, -1], isCanadian = False}
                ]
            == [1.9, 1.0, 2.0, 3.0, 2500, Math.pi, 0, -1]
        )
    && assert
        (
            gatherDoubleValues {address = {street = "Heather", number = 7880.0, age = 79.0}, friendlyList = [2.0, 10.0]}
            == [79, 7880, 2, 10]
        )
    && assert (gatherDoubleValues (Just 2.0) == [])
    ;

/**
 * Traverses a value and gathers leaf values of a specified type within the value into a list. The value is assumed to be built
 * out of list and records (to arbitrary levels of nesting and recursion), with various terminal types. The leaf values that are
 * of the type specified by the type variable "b" in the declaration below are gathered.
 */

gatherLeafValues :: (Typeable a, Typeable b) => a -> [b];
gatherLeafValues value = gatherLeafValues2 (toDynamic value);

gatherLeafValues2 :: Typeable a => Dynamic -> [a];
gatherLeafValues2 value =
    let
        typeOfValue = dynamicUnderlyingType value;

        elementType :: [a] -> a;
        elementType = undefined;

        resultElementType = elementType (gatherLeafValues2 value);
    in
        if typeOfValue == typeOf resultElementType then
            [fromJust (fromDynamic value)]
        else if isListType typeOfValue then
            concatMap gatherLeafValues2 (fromJust (fromDynamicList value))
        else if isRecordType typeOfValue then
            concatMap gatherLeafValues2 (fromJust (dynamicRecordFieldValues value))
        else
            []
    ;

gatherLeafValuesExamples =
    assert (gatherLeafValues (1 + 2.0) == [3.0])
    && assert (gatherLeafValues [10, 20, 4.0] == [10, 20, 4.0])
    && assert
        (
            gatherLeafValues
                [
                    {name = "Anton", age = 1.9, favoriteNumbers = [1.0, 2.0, 3.0], isCanadian = True},
                    {name = "Archimedes", age = 2500, favoriteNumbers = [Math.pi, 0, -1], isCanadian = False}
                ]
            == [1.9, 1.0, 2.0, 3.0, 2500, Math.pi, 0, -1]
        )
    && assert
        (
            gatherLeafValues {address = {street = "Heather", number = 7880.0, age = 79.0}, friendlyList = [2.0, 10.0]}
            == [79.0, 7880, 2, 10]
        )
    && assert (gatherLeafValues (Just 2.0) == ([] :: [Double]))
    && assert (gatherLeafValues (Just 2.0) == [Just 2.0])
    && assert (gatherLeafValues [("apple", 5), ("orange", 4), ("pear", 2.0)] == ["apple", "orange", "pear"])
    && assert (gatherLeafValues [("apple", 5), ("orange", 4), ("pear", 2.0)] == [5.0, 4, 2.0])
    && assert
        (
            gatherLeafValues [("apple", 5), ("orange", 4), ("pear", 2.0)]
            == [("apple", 5), ("orange", 4), ("pear", 2.0)]
        )
    && assert (gatherLeafValues [("apple", 5), ("orange", 4), ("pear", 2.0)] == ([] :: [Boolean]))
    ;

data GroupDataType =
    GroupDataType1
        field1 :: !Int
        field2 :: String
        field3 :: Double |
    GroupDataType2
        field1 :: !Double
        field2 :: Int
        field3 :: String |
    GroupDataType3
        field1 :: !String
        field2 :: Double
        field3 :: Int |
    GroupDataType4
        field2 :: !String
        field3 :: !Double
        field1 :: Int |
    GroupDataType5
        field2 :: Int
        field3 :: String
        field1 :: Double
    ;

testGroupDataType x =
    case x of
    (GroupDataType1 | GroupDataType4) {field1} -> field1 + 2;
    _ -> 0;
    ;

testGroupDataType_2 x =
    case x of
    (GroupDataType1 | GroupDataType5) field1 _ _ -> field1 + 2;
    _ -> 0;
    ;

data GroupDataType2 =
    GroupDataType2_1
        field1 :: !Int
        field2 :: String
        field3 :: Double |
    GroupDataType2_2
        field1 :: !Int
        field2 :: !String
        field3 :: String
    ;

testGroupDataType2 :: GroupDataType2 -> Int;
testGroupDataType2 x =
    case x of
    (GroupDataType2_1 | GroupDataType2_2) {field1} -> testGroupDataType2Helper field1 field1;
    ;

testGroupDataType2Helper :: Int -> Int -> Int;
testGroupDataType2Helper !x y = x + y + 2;

groupDataTest =
    assert (testGroupDataType (GroupDataType4 "a" 1.0 2) == 4)
    && assert (testGroupDataType_2 (GroupDataType5 1 "a" 1.0) == 3)
    && assert (testGroupDataType2 (GroupDataType2_1 7 "a" 1.0) == 16)
    ;

cafOne = 1.0;

addOne x y = x + 1.0;

addOneCAF x y = x + cafOne;

caftest1 x = List.foldLeftStrict addOne 0.0 (take x (repeat 1.0));

caftest2 x = List.foldLeftStrict addOneCAF 0.0 (take x (repeat 1.0));

caftest3 x = List.last (List.take x (Prelude.upFrom 1.0));

caftest4 :: Int -> [Int];
caftest4 !x =
    if x == 0 then
        []
    else
        Prelude.deepSeq (List.take 20 (Prelude.upFrom (1 :: Int))) (caftest4 (x - 1))
    ;

caftest5 :: Int -> [Int];
caftest5 !x =
    if x == 0 then
        []
    else
        Prelude.deepSeq (List.take 10 (Prelude.upFrom (1 :: Int))) (caftest5 (x - 1))
    ;

testMissingCases :: GroupDataType -> String;
testMissingCases x =
    case x of
    GroupDataType3 {} -> "blah";
    ;

strictOutput :: CalValue -> JObject;
strictOutput !element = output element;

testInternalValue :: Prelude.Boolean;
testInternalValue =
    assert (1.0 + unsafeCoerce (input (strictOutput (unsafeCoerce 1.0)) :: CalValue) == 2.0)
    && assert (1.0 + unsafeCoerce (input (output (unsafeCoerce 1.0 :: CalValue)) :: CalValue) == 2.0)
    ;

/** Sums the int list [1..100] n times. So the result is 5050*n. */

sumList :: Int -> Int;
sumList n =
    let
        list :: [Int];
        list = upFromTo 1 100;

        sumListHelper :: Int -> Int -> Int;
        sumListHelper !index !partialSum =
            if index <= 0 then
                partialSum
            else
                sumListHelper (index - 1) (partialSum + List.sum list)
            ;
    in
        sumListHelper n 0
    ;

/** Sums the int array [1..100] n times. So the result is 5050*n. */

sumArray :: Int -> Int;
sumArray n =
    let
        array :: Array Int;
        array = Array.fromList (upFromTo 1 100);

        sumArrayHelper :: Int -> Int -> Int;
        sumArrayHelper !index !partialSum =
            if index <= 0 then
                partialSum
            else
                sumArrayHelper (index - 1) (partialSum + Array.sum array)
            ;
    in
        sumArrayHelper n 0
    ;

/**
 * Like sumArray, but converts the array to a list and uses list's sum each time the array is summed. This simulates using list's
 * functions for arrays.
 */

sumArray_v2 :: Int -> Int;
sumArray_v2 n =
    let
        array :: Array Int;
        array = Array.fromList (upFromTo 1 100);

        arraySum :: Array Int -> Int;
        arraySum !array = List.sum (Array.toList array);

        sumArrayHelper :: Int -> Int -> Int;
        sumArrayHelper !index !partialSum =
            if index <= 0 then
                partialSum
            else
                sumArrayHelper (index - 1) (partialSum + arraySum array)
            ;
    in
        sumArrayHelper n 0
    ;

/** Computes andList n times on a list of 100 True's. */

andListBenchmark :: Int -> Boolean;
andListBenchmark n =
    let
        list :: [Boolean];
        list = List.replicate 100 True;

        helper :: Int -> Boolean;
        helper !index =
            if index <= 0 then
                True
            else if List.andList list then
                helper (index - 1)
            else
                error "unexpected branch"
            ;
    in
        helper n
    ;

/** Computes andArray n times on an array of 100 True's. */

andArrayBenchmark :: Int -> Boolean;
andArrayBenchmark n =
    let
        array :: Array Boolean;
        array = Array.replicate 100 True;

        helper :: Int -> Boolean;
        helper !index =
            if index <= 0 then
                True
            else if Array.andArray array then
                helper (index - 1)
            else
                error "unexpected branch"
            ;
    in
        helper n
    ;

mapListBenchmark :: Int -> Int;
mapListBenchmark n =
    let
        list :: [Int];
        list = replicate 100 0;

        helper :: Int -> [Int] -> [Int];
        helper !index !currentList =
            if index <= n then
                helper (index + 1) (Prelude.deepStrict (map (Prelude.add index)) currentList)
            else
                currentList
            ;
    in
        List.sum (helper 1 list)
    ;

mapArrayBenchmark :: Int -> Int;
mapArrayBenchmark n =
    let
        array :: Array Int;
        array = Array.replicate 100 0;

        helper :: Int -> Array Int -> Array Int;
        helper !index !currentArray =
            if index <= n then
                helper (index + 1) (Array.map (Prelude.add index) currentArray)
            else
                currentArray
            ;
    in
        Array.sum (helper 1 array)
    ;

testForeignResolution = show (Prelude.stringToDouble "9.0") == "9.0";

foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.M2.NullProvider.nullString"
    private nullString :: Prelude.String;

nullStringTesterHelper2 :: Boolean -> Boolean -> Boolean;
nullStringTesterHelper2 b o =
    if b then
        b
    else
        Prelude.seq o b
    ;

nullStringTesterHelper1 :: String -> String -> Boolean;
nullStringTesterHelper1 !s1 !s2 = nullStringTesterHelper2 Prelude.True (s1 == s2);

nullStringTester = nullStringTesterHelper1 nullString "ab";

rlift :: Int -> Int -> Int;
rlift !x !y =
    let
        z = (x + y) / 2;
    in
        if x > y then
            z
        else
            z
    ;

data CommonFields =
    CommonFields1
        f1 :: Int
        f2 :: Double
        f3 :: Int |
    CommonFields2
        f2 :: !Double
        f3 :: !Int
        f1 :: !Int |
    CommonFields3
        f3 :: Int
        f1 :: !Int
        f2 :: !Double
    ;

commonFieldsTest1 x =
    case x of
    (CommonFields1 | CommonFields2) {f1} ->
        let
            z = f1 + 2;
        in
            z + z
        ;
    ;

commonFieldsTest2 x =
    case x of
    (CommonFields3 | CommonFields2) {f1} ->
        let
            z = f1 + 2;
        in
            z + z
        ;
    ;

data SimpleEnum =
    SimpleEnum
    ;

data PrimTypes =
    PTInt
        sf :: !Int
        lf :: Int |
    PTBoolean
        sf :: !Boolean
        lf :: Boolean |
    PTByte
        sf :: !Byte
        lf :: Byte |
    PTChar
        sf :: !Char
        lf :: Char |
    PTDouble
        sf :: !Double
        lf :: Double |
    PTFloat
        sf :: !Float
        lf :: Float |
    PTLong
        sf :: !Long
        lf :: Long |
    PTShort
        sf :: !Short
        lf :: Short |
    PTString
        sf :: !String
        lf :: String |
    PTForeign
        sf :: !MyStringBuilder
        lf :: MyStringBuilder |
    PTForeignPrim
        sf :: !MyInt
        lf :: MyInt |
    PTEnum
        sf :: !SimpleEnum
        lf :: SimpleEnum
    ;

dcfsTest1 !x = x.PTInt.sf == x.PTInt.lf;

dcfsTest2 !x = x.PTBoolean.sf == x.PTBoolean.lf;

dcfsTest3 !x = x.PTByte.sf == x.PTByte.lf;

dcfsTest4 !x = x.PTChar.sf == x.PTChar.lf;

dcfsTest5 !x = x.PTDouble.sf == x.PTDouble.lf;

dcfsTest6 !x = x.PTFloat.sf == x.PTFloat.lf;

dcfsTest7 !x = x.PTLong.sf == x.PTLong.lf;

dcfsTest8 !x = x.PTShort.sf == x.PTShort.lf;

dcfsTest9 !x = x.PTString.sf == x.PTString.lf;

dcfsTest =
    assert (dcfsTest1 (PTInt 1 1))
    && assert (dcfsTest2 (PTBoolean True True))
    && assert (dcfsTest3 (PTByte 1 1))
    && assert (dcfsTest4 (PTChar 'a' 'a'))
    && assert (dcfsTest5 (PTDouble 1 1))
    && assert (dcfsTest6 (PTFloat 1 1))
    && assert (dcfsTest7 (PTLong 1 1))
    && assert (dcfsTest8 (PTShort 1 1))
    && assert (dcfsTest9 (PTString "a" "a"))
    ;

alias1 = alias2;

alias2 = alias1;

data Table =
    Table
        name :: String
        columns :: [Column]
    deriving Debug.Show
    ;

data Column =
    Column
        name :: String
        owner :: Table
    ;

instance Show Column where
    show = showColumn;
    ;

showColumn :: Column -> String;
showColumn column =
    let
        owner = column.Column.owner;

        ownerName = owner.Table.name;

        ownerNColumns = List.length owner.Table.columns;
    in
        Prelude.concat
            [
                "(Column: name = ",
                show column.Column.name,
                " owner = ",
                show ownerName,
                " nOwnerColums = ",
                show ownerNColumns,
                ")"
            ]
    ;

newTable :: String -> Table;
newTable tableName = Table tableName [];

updateColumnOwner :: Table -> Column -> Column;
updateColumnOwner table column =
    case column of
    Column {name} -> Column name table;
    ;

addColumn :: Table -> String -> Table;
addColumn table columnName =
    case table of
    Table {name, columns} ->
        let
            newTable = Table name (Column columnName newTable : map (updateColumnOwner newTable) columns);
        in
            newTable
        ;
    ;

table1 = newTable "Employees";

table2 = addColumn table1 "Name";

table3 = addColumn table2 "Salary";

table4 = addColumn table3 "HireDate";

/**
 * initial version from Yann Le Biannic's Wiki. This is a classic version from various introductory papers on functional
 * programming. However, it is not production quality. For example, the list is filtered twice per pivot selection whereas it
 * really only needs to be done once. It should also be mentioned that this quicksort is sorting a linked list (with O(n) element
 * access) and not an array (with constant time element access), unlike most of the versions for other languages.
 */

quicksort :: [Int] -> [Int];
quicksort source =
    let
        partition_min pivot = filter (\x -> x < pivot);

        partition_max pivot = filter (\x -> x >= pivot);
    in
        case source of
        [] -> [];
        pivot : tail -> quicksort (partition_min pivot tail) ++ [pivot] ++ quicksort (partition_max pivot tail);
    ;

/**
 * Version written by Rick to avoid filtering the list twice per pivot. It still works directly with the O(n) element access list
 * type.
 */

quicksort2 :: [Prelude.Int] -> [Prelude.Int];
quicksort2 !list =
    let
        partition ::
            Prelude.Int -> [Prelude.Int] -> [Prelude.Int] -> [Prelude.Int] -> ([Prelude.Int], [Prelude.Int]);
        partition !pivot !list left right =
            case list of
            [] -> (left, right);
            l : ls ->
                if l < pivot then
                    partition pivot ls (l : left) right
                else
                    partition pivot ls left (l : right)
                ;
            ;
    in
        case list of
        [] -> [];
        l : ls ->
            let
                lr = partition l ls [] [];

                left = Prelude.fst lr;

                right = Prelude.snd lr;
            in
                quicksort2 left ++ l : quicksort2 right
            ;
    ;

/**
 * The [Int] is first converted to an Array Int, this is then output to a JObject (which is actually an int array, by the
 * definition of {@link Array.outputPrimitive@}), which is then input to a JIntArray (this is a downcast), this is then sorted by
 * sorter, the array is then upcasted to a JObject, which is then input to an Array Int, which is then converted to a [Int].
 */

sortWithSpecifiedSorter :: [Prelude.Int] -> (JIntArray -> JIntArray) -> [Prelude.Int];
sortWithSpecifiedSorter !list sorter =
    Array.toList # Array.inputPrimitive # Prelude.output # sorter # Prelude.input # Array.outputPrimitive # Array.fromList $ list
    ;

/** Marshals the [Int] to a Java primitive int array, does an in-place quicksort in a foreign function, then marshalls back. */

quicksort3 :: [Prelude.Int] -> [Prelude.Int];
quicksort3 !list = sortWithSpecifiedSorter list intArray_javaQuicksort;

foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.M2.TestSupport$FastQuicksort.sort"
    intArray_javaQuicksort :: JIntArray -> JIntArray;

/**
 * Marshals the [Int] to a Java primitive int array, does an in-place quicksort using a CAL function with side-effects, then
 * marshals back.
 */

quicksort4 :: [Prelude.Int] -> [Prelude.Int];
quicksort4 !list = sortWithSpecifiedSorter list quicksortIntArray_v1;

/**
 * Marshals the [Int] to a Java primitive int array, does an in-place quicksort using a CAL function with side-effects, then
 * marshals back.
 */

quicksort5 :: [Prelude.Int] -> [Prelude.Int];
quicksort5 !list = sortWithSpecifiedSorter list quicksortIntArray_v2;

/**
 * Marshals the [Int] to a Java primitive int array, does an in-place quicksort using a CAL function with side-effects, then
 * marshals back.
 */

quicksort6 :: [Prelude.Int] -> [Prelude.Int];
quicksort6 !list = sortWithSpecifiedSorter list quicksortIntArray_v3;

data foreign unsafe import jvm "int[]" JIntArray deriving Inputable, Outputable;

foreign unsafe import jvm "newArray" intArray_new :: Int -> JIntArray;

foreign unsafe import jvm "lengthArray" intArray_length :: JIntArray -> Int;

foreign unsafe import jvm "subscriptArray" intArray_subscript :: JIntArray -> Int -> Int;

foreign unsafe import jvm "updateArray" intArray_update :: JIntArray -> Int -> Int -> Int;

foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.M2.TestSupport$IntArray.swap"
    intArray_swap :: JIntArray -> Int -> Int -> ();

/**
 * Quicksort on primitive int arrays implemented fully in CAL without the use of unneccessary foreign functions.
 *
 * Note: length, subscript and update for Java arrays correspond to Java language constructs rather than functions. We need to
 * wrap these with helper Java functions to access this functionality from CAL.
 */

quicksortIntArray_v1 :: JIntArray -> JIntArray;
quicksortIntArray_v1 !array =
    let
        swap :: Int -> Int -> ();
        swap !index1 !index2 =
            let
                swapHelper !temp =
                    intArray_update array index2 (intArray_subscript array index1)
                    `seq`
                    intArray_update array index1 temp
                    `seq`
                    ()
                    ;
            in
                swapHelper (intArray_subscript array index2)
            ;

        qsort :: Int -> Int -> JIntArray;
        qsort !begin !end =
            if begin < end then
                let
                    partition :: Int -> Int -> Int -> Int;
                    partition !i !index !pivot =
                        if i >= end then
                            swap index end
                            `seq`
                            index
                        else if intArray_subscript array i <= pivot then
                            swap i index
                            `seq`
                            partition (i + 1) (index + 1) pivot
                        else
                            partition (i + 1) index pivot
                        ;

                    index = partition begin begin (intArray_subscript array end);
                in
                    qsort begin (index - 1)
                    `seq`
                    qsort (index + 1) end
            else
                array
            ;
    in
        qsort 0 (intArray_length array - 1)
    ;

/** Like quicksortIntArray_v1 but uses a foreign function for swapping array elements. */

quicksortIntArray_v2 :: JIntArray -> JIntArray;
quicksortIntArray_v2 !array =
    let
        qsort :: Int -> Int -> JIntArray;
        qsort !begin !end =
            if begin < end then
                let
                    partition :: Int -> Int -> Int -> Int;
                    partition !i !index !pivot =
                        if i >= end then
                            intArray_swap array index end
                            `seq`
                            index
                        else if intArray_subscript array i <= pivot then
                            intArray_swap array i index
                            `seq`
                            partition (i + 1) (index + 1) pivot
                        else
                            partition (i + 1) index pivot
                        ;

                    index = partition begin begin (intArray_subscript array end);
                in
                    qsort begin (index - 1)
                    `seq`
                    qsort (index + 1) end
            else
                array
            ;
    in
        qsort 0 (intArray_length array - 1)
    ;

/**
 * Quicksort on primitive int arrays implemented fully in CAL without the use of unneccessary foreign functions.
 *
 * Note: length, subscript and update for Java arrays correspond to Java language constructs rather than functions. We need to
 * wrap these with helper Java functions to access this functionality from CAL.
 *
 * The difference with v1 is in the definition of the swap function to use an eager let variable instead of a local swapHelper
 * function, and the
 */

quicksortIntArray_v3 :: JIntArray -> JIntArray;
quicksortIntArray_v3 !array =
    let
        swap :: Int -> Int -> ();
        swap !index1 !index2 =
            let
                temp = eager (intArray_subscript array index2);
            in
                temp
                `seq`
                intArray_update array index2 (intArray_subscript array index1)
                `seq`
                intArray_update array index1 temp
                `seq`
                ()
            ;

        qsort :: Int -> Int -> JIntArray;
        qsort !begin !end =
            if begin < end then
                let
                    partition :: Int -> Int -> Int -> Int;
                    partition !i !index !pivot =
                        if i >= end then
                            swap index end
                            `seq`
                            index
                        else if intArray_subscript array i <= pivot then
                            swap i index
                            `seq`
                            partition (i + 1) (index + 1) pivot
                        else
                            partition (i + 1) index pivot
                        ;

                    index = eager (partition begin begin (intArray_subscript array end));
                in
                    qsort begin (index - 1)
                    `seq`
                    qsort (index + 1) end
            else
                array
            ;
    in
        qsort 0 (intArray_length array - 1)
    ;

randomIntArray :: Int -> JIntArray;
randomIntArray !size = input # Array.outputPrimitive # Array.fromList $ take size (randomInts 2006);

testSortingBenchmarks =
    let
        list = take 25 (randomInts 2006);

        sortedList = quicksort list;
    in
        assert (sortedList == quicksort2 list)
        && assert (sortedList == quicksort3 list)
        && assert (sortedList == quicksort4 list)
        && assert (sortedList == quicksort5 list)
        && assert (sortedList == quicksort6 list)
    ;

foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.M2.TestSupport$QuickPrimeGenerator.generate"
    java_sieveBasedGetNthPrime :: Int -> Int;

sieveBasedGetNthPrime :: Int -> Int;
sieveBasedGetNthPrime !rank =
    let
        primes = Prelude.eager (intArray_new (rank + 1));

        generate :: Int -> Int -> Int;
        generate !i !candidate =
            if i < rank then
                let
                    maxDivisor :: Int;
                    maxDivisor = Prelude.eager (Prelude.truncate (Math.sqrt (toDouble candidate)));

                    isPrime :: Int -> Boolean;
                    isPrime !j =
                        if j > i then
                            True
                        else
                            let
                                divisor = Prelude.eager (intArray_subscript primes j);
                            in
                                if candidate % divisor == 0 then
                                    False
                                else if divisor > maxDivisor then
                                    True
                                else
                                    isPrime (j + 1)
                        ;
                in
                    if isPrime 0 then
                        intArray_update primes (i + 1) candidate
                        `seq`
                        generate (i + 1) (candidate + 2)
                    else
                        generate i (candidate + 2)
            else
                candidate - 2
            ;
    in
        intArray_update primes 0 3
        `seq`
        intArray_update primes 1 5
        `seq`
        generate 1 7
    ;

testSieveBasedPrimeGenerators =
    assert (map sieveBasedGetNthPrime (upFromTo 1 20) == map java_sieveBasedGetNthPrime (upFromTo 1 20))
    && assert (map sieveBasedGetNthPrime (upFromTo 1 10) == [5, 7, 11, 13, 17, 19, 23, 29, 31, 37])
    ;

sieveBasedGetNthPrime2 :: Int -> Int;
sieveBasedGetNthPrime2 !rank =
    let
        primes = Prelude.eager (intArray_new (rank + 1));

        /**
         * This function has the side effect of populating the array primes with the prime of rank 0 (3), prime of rank 2 (5),
         * ..., prime of rank 'rank'.
         *
         * @arg i an index into the array primes. the primes array is populated at indices 0, ..., i with a prime
         * @arg candidate candidate value to test for primality. This value is the next possible prime greater than the primes_i.
         * @return the prime of rank 'rank'.
         */
        populatePrimesArrayLoop :: Int -> Int -> Int;
        populatePrimesArrayLoop !i !candidate =
            if i < rank then
                let
                    maxDivisor :: Int;
                    maxDivisor = Prelude.eager (Prelude.truncate (Math.sqrt (toDouble candidate)));

                    /**
                     * assumes that primes is populated with successive odd primes from index 0 .. i.
                     * @arg candidate to test for primality. This value is the next possible prime greater than primes_i.
                     * @return true if candidate is prime.
                     */
                    isPrime :: Int -> Boolean;
                    isPrime !candidate =
                        let
                            isPrimeLoop :: Int -> Boolean;
                            isPrimeLoop !j =
                                if j > i then
                                    True
                                else
                                    let
                                        divisor = Prelude.eager (intArray_subscript primes j);
                                    in
                                        if candidate % divisor == 0 then
                                            False
                                        else if divisor > maxDivisor then
                                            True
                                        else
                                            isPrimeLoop (j + 1)
                                ;
                        in
                            isPrimeLoop 0
                        ;
                in
                    if isPrime candidate then
                        intArray_update primes (i + 1) candidate
                        `seq`
                        populatePrimesArrayLoop (i + 1) (candidate + 2)
                    else
                        populatePrimesArrayLoop i (candidate + 2)
            else
                candidate - 2
            ;
    in
        intArray_update primes 0 3
        `seq`
        intArray_update primes 1 5
        `seq`
        populatePrimesArrayLoop 1 7
    ;

testSieveBasedPrimeGenerators2 =
    assert (map sieveBasedGetNthPrime2 (upFromTo 1 20) == map java_sieveBasedGetNthPrime (upFromTo 1 20))
    && assert (map sieveBasedGetNthPrime2 (upFromTo 1 10) == [5, 7, 11, 13, 17, 19, 23, 29, 31, 37])
    ;

data Cursor =
    private Cursor
        state :: !CalValue
        isAfterLastRow :: !Boolean
        advancedCursor :: Cursor
    ;

sevens :: [Int];
sevens = 7 : sevens;

naturals :: [Integer];
naturals = upFrom 1;

strangeTuple :: (Int, Maybe Char, (Int, Maybe Char));
strangeTuple =
    let
        x = Just 'z';
    in
        (20, x, (20, x))
    ;

/**
 * some examples of the use of showInternal, showInternalGraph and internalValueStats for a talk on April 18, 2006. Also see the
 * examples in Debug_Tests.testShowInternalLecc
 */
debugFunctionsTalk =
    assert (showInternal sevens == "M2.sevens")
    && assert
        (
            output (take 10 sevens)
                `seq`
                showInternal sevens
            == "<@1 = (Prelude.Cons 7 <@1>)>"
        )
    && assert (showInternalGraph sevens == "*<@1 = (Prelude.Cons 7 <@1>)>")
    && assert (show (internalValueStats sevens) == "(nDistinctNodes = 3, nDistinctIndirectionNodes = 1, nSharedNodes = 1)")
    && assert (showInternalGraph naturals == "M2.naturals")
    && assert
        (
            output (take 5 naturals)
                `seq`
                showInternal naturals
            == "(Prelude.Cons 1 (Prelude.Cons 2 (Prelude.Cons 3 (Prelude.Cons 4 (Prelude.Cons 5 (Prelude.upFromInteger (Prelude.addInteger 5 1)))))))"
        )
    && assert
        (
            showInternalGraph naturals
            == "*(Prelude.Cons 1 *(Prelude.Cons 2 *(Prelude.Cons 3 *(Prelude.Cons 4 *(Prelude.Cons 5 (Prelude.upFromInteger (Prelude.addInteger 5 1)))))))"
        )
    && assert
        (
            output (take 3 naturals)
                `seq`
                showInternalGraph naturals
            == "*(Prelude.Cons 1 (Prelude.Cons 2 (Prelude.Cons 3 (Prelude.Cons 4 *(Prelude.Cons 5 (Prelude.upFromInteger (Prelude.addInteger 5 1)))))))"
        )
    && assert (show (internalValueStats naturals) == "(nDistinctNodes = 16, nDistinctIndirectionNodes = 2, nSharedNodes = 0)")
    && assert
        (
            output strangeTuple
                `seq`
                showInternal strangeTuple
            == "(20, <@1 = (Prelude.Just z)>, (20, <@1>))"
        )
    && assert (showInternalGraph strangeTuple == "*(<@1 = 20>, <@2 = (Prelude.Just z)>, (<@1>, <@2>))")
    && assert
        (
            output (take 5 M1.allPrimes)
                `seq`
                showInternal M1.allPrimes
            == "(Prelude.Cons 2 (Prelude.Cons 3 (Prelude.Cons 5 (Prelude.Cons 7 (Prelude.Cons 11 (M1.sieve (List.filter (M1.nonMultiple 11) (List.filter (M1.nonMultiple 7) (List.filter (M1.nonMultiple 5) (List.filter (M1.nonMultiple 3) (List.filter (M1.nonMultiple 2) (Prelude.upFromInt 12))))))))))))"
        )
    ;

myZip !list1 list2 =
    ("M2.myZip " ++ showInternal list1 ++ " " ++ showInternal list2 ++ "\n")
    `Debug.trace`
    (
        case list1 of
        x : xs ->
            case list2 of
            y : ys -> (x, y) : myZip xs ys;
            [] -> [];
            ;
        [] -> [];
    )
    ;

sumFirstNPrimes !n =
    let
        first10Primes = map getNthPrime (upFromTo 0 (n - 1));
    in
        setTracingEnabled False
        `seq`
        first10Primes
        `deepSeq`
        setTracingEnabled True
        `seq`
        sum first10Primes
    ;

sumFirstNPrimes2 !n =
    let
        first10Primes = map getNthPrime (upFromTo 0 (n - 1));
    in
        first10Primes `deepSeq` sum first10Primes
    ;

testSMDefaultPrivate = undefined;

private testSMPrivate = undefined;

protected testSMProtected = undefined;

testSM = undefined;

foreign unsafe import jvm "static field java.lang.Math.PI" testSMDefaultPrivateForeign :: Double;

foreign unsafe import jvm "static field java.lang.Math.PI" private testSMPrivateForeign :: Double;

foreign unsafe import jvm "static field java.lang.Math.PI" protected testSMProtectedForeign :: Double;

foreign unsafe import jvm "static field java.lang.Math.PI" public testSMPublicForeign :: Double;

class TestSMDefaultPrivateClass a where
    testSMDefaultPrivateMethod :: a;
    ;

private class TestSMPrivateClass a where
    private testSMPrivateMethod :: a;
    ;

protected class TestSMProtectedClass a where
    protected testSMProtectedMethod :: a;
    ;

public class TestSMPublicClass a where
    public testSMPublicMethod :: a;
    ;

data TestSMDefaultPrivateType =
    TestSMDefaultPrivateDataCons
    ;

data private TestSMPrivateType =
    private TestSMPrivateDataCons
    ;

data protected TestSMProtectedType =
    protected TestSMProtectedDataCons
    ;

data public TestSMPublicType =
    public TestSMPublicDataCons
    ;

data foreign unsafe import jvm "char" TestSMDefaultPrivateForeignType;

data foreign unsafe import jvm private "char" private TestSMPrivateForeignType;

data foreign unsafe import jvm protected "char" protected TestSMProtectedForeignType;

data foreign unsafe import jvm public "char" public TestSMPublicForeignType;

/**
 * A tail recursion function with more than 15 arguments. This is used to test a situation which requires generating a lazy
 * application node specific to the function. Lazy application nodes for up to 15 arguments are built into the run time.
 */

largeArityTailRecursion ::
    [Double]
    -> Double
    -> Double
    -> Double
    -> Double
    -> Double
    -> Double
    -> Double
    -> Double
    -> Double
    -> Double
    -> Double
    -> Double
    -> Double
    -> Double
    -> Double
    -> Double
    -> Double;
largeArityTailRecursion !a !b c d e f g h i j k l m n o p q =
    case a of
    x : xy -> largeArityTailRecursion xy (b + 1.0) c d e f g h i j k l m n o p q;
    [] -> b;
    ;

/** Test a lazy fully saturated application of a tail recursive function with more than 15 arguments. */

testLargArityLazyTailRecursion :: Boolean;
public testLargArityLazyTailRecursion =
    let
        helper :: Double -> Boolean;
        helper x = x + 1.0 == 5000001.0;
    in
        helper (largeArityTailRecursion (upFromTo 1.0 5000000) 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0)
    ;

data DCFsTest =
    DCFsTest x :: (Int -> Int)
    ;

testStrictDCFieldSelection d = d.DCFsTest.x 1 + 1;

partialAppTestHelper1 :: Prelude.Double -> Prelude.Double -> Prelude.Double -> Prelude.Double;
partialAppTestHelper1 x y z =
    if z > 0 then
        partialAppTestHelper1 x y (z - 1)
    else
        Prelude.error "Shouldn\'t be called."
        `seq`
        partialAppTestHelper2 x y
    ;

partialAppTestHelper2 :: Prelude.Double -> Prelude.Double -> Prelude.Double;
partialAppTestHelper2 x y =
    if x > 0 then
        partialAppTestHelper1 x x x
    else
        0
    ;

partialAppTest =
    partialAppTestHelper1 1.0 1.0
    `seq`
    Prelude.True
    ;

/** @return true if the testing predicates in this module all run successfully. */

mainM2 :: Boolean;
public mainM2 =
    test1
        && test2
        && test3
        && test4
        && test5
        && test6
        && test7
        && test8
        && test9
        && test10
        && test11
        && test12
        && test13
        && test14
        && test15
        && test16
        && test17
        && test18
        && test19
        && test20
        && test21
        && test22
        && test23
        && test24
        && test25
        && test26
        && lazyTest
        && M1.testOverloading
        && M1.testForeignFunctions
        && badgemtest
        && zap4
        && ciTest1
        && ciTest2
        && ciTest3
        && testZipperWith
        && "abc" ++ "defg" == "abcdefg"
        && List.take 10 M1.allPrimes ++ List.drop 10 (List.take 20 M1.allPrimes) == List.take 20 M1.allPrimes
        && Nofib.testBenchmarks
        && testAlternativeImplementationsOfPreludeFunctions
        && testBooleanCaseStatements
        && RecordTests.testModule
        && letVarTest
        && testSeq
        && testSeq2
        && testStrictDataConstructors
        && testStrictFunctions
        && testSum
        && orListOldExamples
        && andListOldExamples
        && anyOldExamples
        && allOldExamples
        && testLength
        && verificationError == 0
        && ternaryTest [1.0, -1.0, 0.0, 2.0, -3.0] == [-1.0, 0.0, -3.0]
        && testFindIndices
        && removeDuplicatesByOldExamples
        && LegacyTuple.testLegacyTupleModule
        && testLiftTests
        && testLetters
        && testStuff
        && sum2 [1, 2, 3] == 6
        && sum2LiftedTraditionally [2, 3, 4, 5] == 14
        && sum2JohnssonLifted [2, 5, 10] == 17
        && testOutputListWithOld
        && testInputListWithOld
        && testExpressionTypeSignatures
        && caseTest
        && Debug_Tests.testModule
        && testLetVarInlining
        && testRecordOutIn
        && testListOutIn
        && testBackquotedOperators
        && testMyMaybeDerivedInstances
        && testMyTuple2DerivedInstances
        && testMyComposersEnumDerivedInstances
        && testMyUnitDerivedInstances
        && testMyBooleanDerivedInstances
        && testMyWrapDerivedInstances
        && testMyOrderingDerivedInstances
        && testMyBottomMiddleTopDerivedInstances
        && testMyABCDEFGDerivedInstances
        && testMyFooBarBazDerivedInstances
        && testMyListDerivedInstances
        && testMyTuple3DerivedInstances
        && testMyTuple3BDerivedInstances
        && testPreludeDerivedOrdInstances
        && testMyPhantomType1DerivedInstances
        && testMyPhantomType2DerivedInstances
        && M1.testTripleDerivedInstances
        && testMedEnumDerivedInstances
        && testOutThenInMyInt
        && testOutThenInMyLong
        && testMyString
        && testComposeOpPrecedence
        && testComposeOpSemantics
        && testApplyOpAssociativity
        && testApplyOpPrecedence
        && testApplyOpSemantics
        && testDeepSeq
        && Shape_Tests.testShapeTestsModule
        && testDerivedEnumIndependence
        && testDerivedForeignInstances
        && testDerivedForeignPrimitiveInstances
        && testNamedDataConstructors
        && InliningTests.testMain
        && testLiftedExpressions Prelude.True
        && testDerivedIntEnumInstances
        && testMarshallingJBoolean
        && testIntCase
        && testCharCase
        && gatherDoubleValuesExamples
        && gatherLeafValuesExamples
        && groupDataTest
        && testInternalValue
        && assert QuickCheck_Tests.testModule
        && assert Exception_Tests.testModule
        && assert Prelude_Tests.testModule
        && assert Record_Tests.testModule
        && assert List.testModule
        && assert List_Tests.testModule
        && assert String.testModule
        && assert String_Tests.testModule
        && assert Array.testModule
        && assert Array_Tests.testModule
        && assert Bits_Tests.testModule
        && assert Char.testModule
        && assert Char_Tests.testModule
        && assert Debug_Tests.testModule
        && assert Decimal.testModule
        && assert Decimal_Tests.testModule
        && assert Dynamic.testModule
        && assert Dynamic_Tests.testModule
        && assert nullStringTester
        && assert dcfsTest
        && assert RuntimeRegression.exerciseLetVars
        && assert RuntimeRegression.exerciseAliases
        && assert RuntimeRegression.exercise64KLimit
        && assert RuntimeRegression.exercisePartialApplications
        && assert RuntimeRegression.exerciseUnboxedFieldExtraction
        && assert RuntimeRegression.exerciseLetVarScoping
        && assert RuntimeRegression.exerciseSeq
        && assert RuntimeRegression.exerciseUnoptimizedApplications
        && assert RuntimeRegression.exerciseUnboxedReturns
        && assert Memoize_Tests.testModule
        && assert testSortingBenchmarks
        && assert testSieveBasedPrimeGenerators
        && assert testSieveBasedPrimeGenerators2
        && assert Random_Tests.testModule
        && assert Map_Tests.testModule
        && assert LongMap_Tests.testModule
        && assert IntMap_Tests.testModule
        && assert Set_Tests.testModule
        && assert Functor_Tests.testModule
        && assert Monad_Tests.testModule
        && assert System_Tests.testModule
        && assert Locale_Tests.testModule
        && assert MessageFormat_Tests.testModule
        && assert (testStrictDCFieldSelection (DCFsTest (add 1)) == 3)
        && assert partialAppTest
    || error "M2.mainM2 failed."
    ;

//ensure comments at the end of the file are maintained!

/* multiline too*/
//cat
