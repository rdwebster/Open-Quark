/*
 * <!--
 *  
 * **************************************************************
 * This Java source has been automatically generated.
 * MODIFICATIONS TO THIS SOURCE MAY BE OVERWRITTEN - DO NOT MODIFY THIS FILE
 * **************************************************************
 *  
 *  
 * This file (CAL_CollectionUtilities.java)
 * was generated from CAL module: Cal.Experimental.Utilities.CollectionUtilities.
 * The constants and methods provided are intended to facilitate accessing the
 * Cal.Experimental.Utilities.CollectionUtilities module from Java code.
 *  
 * Creation date: Fri Sep 21 16:02:56 PDT 2012
 * --!>
 *  
 */

package org.openquark.cal.module.Cal.Experimental.Utilities;

import org.openquark.cal.compiler.ModuleName;
import org.openquark.cal.compiler.QualifiedName;
import org.openquark.cal.compiler.SourceModel;

/**
 * Utilities for manipulating collections.
 * <p>
 * Collected from other modules by a variety of authors.
 */
public final class CAL_CollectionUtilities {
	public static final ModuleName MODULE_NAME = 
		ModuleName.make("Cal.Experimental.Utilities.CollectionUtilities");

	/**
	 * This inner class (Functions) contains constants
	 * and methods related to binding to CAL functions in the Cal.Experimental.Utilities.CollectionUtilities module.
	 */
	public static final class Functions {
		/**
		 * Determines whether all elements in a list are equal.
		 * @param elements (CAL type: <code>Cal.Core.Prelude.Eq a => [a]</code>)
		 *          the list to examine.
		 * @return (CAL type: <code>Cal.Core.Prelude.Boolean</code>) 
		 *          <code>Cal.Core.Prelude.True</code> if no two elements in the list have different values;
		 * <code>Cal.Core.Prelude.False</code> otherwise.
		 */
		public static final SourceModel.Expr allEquals(SourceModel.Expr elements) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.allEquals), elements});
		}

		/**
		 * Name binding for function: allEquals.
		 * @see #allEquals(org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName allEquals = 
			QualifiedName.make(CAL_CollectionUtilities.MODULE_NAME, "allEquals");

		/**
		 * Retrieve part of an array as a list
		 * @param array (CAL type: <code>Cal.Collections.Array.Array a</code>)
		 *          the array we're going to create a part of
		 * @param fromIndex (CAL type: <code>Cal.Core.Prelude.Int</code>)
		 *          the first item in the array to retrive
		 * @param toIndex (CAL type: <code>Cal.Core.Prelude.Int</code>)
		 *          the exclusive index of the item beyond the last ont to retrieve
		 * @return (CAL type: <code>[a]</code>) 
		 */
		public static final SourceModel.Expr arraySubList(SourceModel.Expr array, SourceModel.Expr fromIndex, SourceModel.Expr toIndex) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.arraySubList), array, fromIndex, toIndex});
		}

		/**
		 * @see #arraySubList(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 * @param array
		 * @param fromIndex
		 * @param toIndex
		 * @return the SourceModel.Expr representing an application of arraySubList
		 */
		public static final SourceModel.Expr arraySubList(SourceModel.Expr array, int fromIndex, int toIndex) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.arraySubList), array, SourceModel.Expr.makeIntValue(fromIndex), SourceModel.Expr.makeIntValue(toIndex)});
		}

		/**
		 * Name binding for function: arraySubList.
		 * @see #arraySubList(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName arraySubList = 
			QualifiedName.make(
				CAL_CollectionUtilities.MODULE_NAME, 
				"arraySubList");

		/**
		 * Generates combinations of values where the values at each level are based on the preceding values in the combination.
		 * The first level of values will be obtained by calling the first levelValueFn with an empty list argument.
		 * For each of these values, the 2nd level of values will be generated by calling the 2nd levelValueFn with the a list containing the 
		 * first level value, and so on....
		 * @param levelValueFns (CAL type: <code>[[a] -> [a]]</code>)
		 *          the functions to generate the values for each level based on the previous values in the combination
		 * @return (CAL type: <code>[[a]]</code>) 
		 *          combinations of values where the values at each level are based on the preceding values in the combination;
		 * if the list of levelValueFns is empty, then [[]] will be returned
		 */
		public static final SourceModel.Expr combinationsBy(SourceModel.Expr levelValueFns) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.combinationsBy), levelValueFns});
		}

		/**
		 * Name binding for function: combinationsBy.
		 * @see #combinationsBy(org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName combinationsBy = 
			QualifiedName.make(
				CAL_CollectionUtilities.MODULE_NAME, 
				"combinationsBy");

		/**
		 * Performs an unordered comparison of two lists, after discarding duplicates
		 * from both.
		 * @param lst1 (CAL type: <code>Cal.Core.Prelude.Eq a => [a]</code>)
		 *          the first list to compare.
		 * @param lst2 (CAL type: <code>Cal.Core.Prelude.Eq a => [a]</code>)
		 *          the second list to compare.
		 * @return (CAL type: <code>Cal.Core.Prelude.Boolean</code>) 
		 *          <code>Cal.Core.Prelude.True</code> if the list contain the same elements, disregarding
		 * order and duplication; <code>Cal.Core.Prelude.False</code> otherwise.
		 */
		public static final SourceModel.Expr equalsListUnordered(SourceModel.Expr lst1, SourceModel.Expr lst2) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.equalsListUnordered), lst1, lst2});
		}

		/**
		 * Name binding for function: equalsListUnordered.
		 * @see #equalsListUnordered(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName equalsListUnordered = 
			QualifiedName.make(
				CAL_CollectionUtilities.MODULE_NAME, 
				"equalsListUnordered");

		/**
		 * Extracts the first element of the list for which the predicate function
		 * returns <code>Cal.Core.Prelude.True</code>.
		 * @param predicate (CAL type: <code>a -> Cal.Core.Prelude.Boolean</code>)
		 *          the predicate function for extracting an element.
		 * @param list (CAL type: <code>[a]</code>)
		 *          the list from which to extract the element.
		 * @return (CAL type: <code>(Cal.Core.Prelude.Maybe a, [a])</code>) 
		 *          <code>(Cal.Core.Prelude.Just element, otherElements)</code> if such an element
		 * exists; <code>(Cal.Core.Prelude.Nothing, allElements)</code> otherwise.
		 */
		public static final SourceModel.Expr extractFirst(SourceModel.Expr predicate, SourceModel.Expr list) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.extractFirst), predicate, list});
		}

		/**
		 * Name binding for function: extractFirst.
		 * @see #extractFirst(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName extractFirst = 
			QualifiedName.make(
				CAL_CollectionUtilities.MODULE_NAME, 
				"extractFirst");

		/**
		 * Lazily filters an array.
		 * <p>
		 * <strong>Note</strong>: returns a list rather than an array to prevent eager evaluation.
		 * 
		 * @param filterFn (CAL type: <code>a -> Cal.Core.Prelude.Boolean</code>)
		 *          the filter function (determines which array elements are present
		 * in the returned list).
		 * @param array (CAL type: <code>Cal.Collections.Array.Array a</code>)
		 *          the array to be filtered.
		 * @return (CAL type: <code>[a]</code>) 
		 *          a filtered list.
		 */
		public static final SourceModel.Expr filterArrayToList(SourceModel.Expr filterFn, SourceModel.Expr array) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.filterArrayToList), filterFn, array});
		}

		/**
		 * Name binding for function: filterArrayToList.
		 * @see #filterArrayToList(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName filterArrayToList = 
			QualifiedName.make(
				CAL_CollectionUtilities.MODULE_NAME, 
				"filterArrayToList");

		/**
		 * Filters the elements of the first list using a predicate function and returns
		 * the corresponding elements of the second list.
		 * @param matchFn (CAL type: <code>a -> Cal.Core.Prelude.Boolean</code>)
		 *          a predicate function that will return <code>Cal.Core.Prelude.True</code> when an
		 * element of the desired form is tested.
		 * @param lst1 (CAL type: <code>[a]</code>)
		 *          the list to filter with the predicate function.
		 * @param lst2 (CAL type: <code>[b]</code>)
		 *          the list of corresponding elements.
		 * @return (CAL type: <code>[b]</code>) 
		 *          the elements of the second list corresponding to the elements of the
		 * first list for which the predicate function returns <code>Cal.Core.Prelude.True</code>.
		 */
		public static final SourceModel.Expr filterCorrespondingList(SourceModel.Expr matchFn, SourceModel.Expr lst1, SourceModel.Expr lst2) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.filterCorrespondingList), matchFn, lst1, lst2});
		}

		/**
		 * Name binding for function: filterCorrespondingList.
		 * @see #filterCorrespondingList(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName filterCorrespondingList = 
			QualifiedName.make(
				CAL_CollectionUtilities.MODULE_NAME, 
				"filterCorrespondingList");

		/**
		 * Finds the first element in the first array for which the predicate function
		 * returns <code>Cal.Core.Prelude.True</code>, if any, and returns the corresponding element in the
		 * second array.
		 * @param matchFn (CAL type: <code>a -> Cal.Core.Prelude.Boolean</code>)
		 *          a predicate function that will return <code>Cal.Core.Prelude.True</code> when an
		 * element of the desired form is tested.
		 * @param array1 (CAL type: <code>Cal.Collections.Array.Array a</code>)
		 *          the array in which to search.
		 * @param array2 (CAL type: <code>Cal.Collections.Array.Array b</code>)
		 *          the array from which to return an element.
		 * @return (CAL type: <code>Cal.Core.Prelude.Maybe b</code>) 
		 *          <code>Cal.Core.Prelude.Just element</code> if <code>matchFn element</code> returns
		 * <code>Cal.Core.Prelude.True</code> and <code>Cal.Core.Prelude.Nothing</code> otherwise.
		 */
		public static final SourceModel.Expr findInCorrespondingArray(SourceModel.Expr matchFn, SourceModel.Expr array1, SourceModel.Expr array2) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.findInCorrespondingArray), matchFn, array1, array2});
		}

		/**
		 * Name binding for function: findInCorrespondingArray.
		 * @see #findInCorrespondingArray(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName findInCorrespondingArray = 
			QualifiedName.make(
				CAL_CollectionUtilities.MODULE_NAME, 
				"findInCorrespondingArray");

		/**
		 * Finds the first element in the first list for which the predicate function
		 * returns <code>Cal.Core.Prelude.True</code>, if any, and returns the corresponding element in the
		 * second list.
		 * @param matchFn (CAL type: <code>a -> Cal.Core.Prelude.Boolean</code>)
		 *          a predicate function that will return <code>Cal.Core.Prelude.True</code> when an
		 * element of the desired form is tested.
		 * @param lst1 (CAL type: <code>[a]</code>)
		 *          the list in which to search.
		 * @param lst2 (CAL type: <code>[b]</code>)
		 *          the list from which to return an element.
		 * @return (CAL type: <code>Cal.Core.Prelude.Maybe b</code>) 
		 *          <code>Cal.Core.Prelude.Just element</code> if <code>matchFn element</code> returns
		 * <code>Cal.Core.Prelude.True</code> and <code>Cal.Core.Prelude.Nothing</code> otherwise.
		 */
		public static final SourceModel.Expr findInCorrespondingList(SourceModel.Expr matchFn, SourceModel.Expr lst1, SourceModel.Expr lst2) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.findInCorrespondingList), matchFn, lst1, lst2});
		}

		/**
		 * Name binding for function: findInCorrespondingList.
		 * @see #findInCorrespondingList(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName findInCorrespondingList = 
			QualifiedName.make(
				CAL_CollectionUtilities.MODULE_NAME, 
				"findInCorrespondingList");

		/**
		 * <code>findIndexAndValue predicate list</code> returns the first index of list for which the 
		 * predicate function is <code>Cal.Core.Prelude.True</code> along with the matching list item,
		 * if there is one, or <code>Cal.Core.Prelude.Nothing</code> otherwise. The index is 0-based.
		 * <p>
		 * e.g. <code>findIndex Cal.Core.Prelude.isEven [1, 1, 4, 1, 2, 1, 1, 6] == Cal.Core.Prelude.Just (2, 4)</code>
		 * 
		 * 
		 * <dl><dt><b>See Also:</b>
		 * <dd><b>Functions and Class Methods:</b> Cal.Collections.List.findIndex
		 * </dl>
		 * 
		 * @param predicate (CAL type: <code>a -> Cal.Core.Prelude.Boolean</code>)
		 *          a predicate function to be applied to the elements of the list.
		 * @param list (CAL type: <code>[a]</code>)
		 *          the list to be searched.
		 * @return (CAL type: <code>Cal.Core.Prelude.Maybe (Cal.Core.Prelude.Int, a)</code>) 
		 *          the first index of list for which the predicate function is <code>Cal.Core.Prelude.True</code> along with the 
		 * matching list item, if there is one, or <code>Cal.Core.Prelude.Nothing</code> otherwise.
		 */
		public static final SourceModel.Expr findIndexAndValue(SourceModel.Expr predicate, SourceModel.Expr list) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.findIndexAndValue), predicate, list});
		}

		/**
		 * Name binding for function: findIndexAndValue.
		 * @see #findIndexAndValue(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName findIndexAndValue = 
			QualifiedName.make(
				CAL_CollectionUtilities.MODULE_NAME, 
				"findIndexAndValue");

		/**
		 * Folds a function over the 2 specified lists.
		 * This is the same as <code>Cal.Collections.List.foldLeftStrict</code>, except that 2 lists are folded instead of one.
		 * The folding will stop when the end of either of the lists is reached.
		 * 
		 * <dl><dt><b>See Also:</b>
		 * <dd><b>Functions and Class Methods:</b> Cal.Collections.List.foldLeftStrict
		 * </dl>
		 * 
		 * @param foldFunction (CAL type: <code>a -> b -> c -> a</code>)
		 *          the function to be used in folding the lists
		 * @param initialValue (CAL type: <code>a</code>)
		 *          the initial value for the folding process
		 * @param list1 (CAL type: <code>[b]</code>)
		 *          the first list to be folded over
		 * @param list2 (CAL type: <code>[c]</code>)
		 *          the second list to be folded over
		 * @return (CAL type: <code>a</code>) 
		 *          the single result obtained from folding <code>foldFunction</code> over the lists
		 */
		public static final SourceModel.Expr fold2LeftStrict(SourceModel.Expr foldFunction, SourceModel.Expr initialValue, SourceModel.Expr list1, SourceModel.Expr list2) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.fold2LeftStrict), foldFunction, initialValue, list1, list2});
		}

		/**
		 * Name binding for function: fold2LeftStrict.
		 * @see #fold2LeftStrict(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName fold2LeftStrict = 
			QualifiedName.make(
				CAL_CollectionUtilities.MODULE_NAME, 
				"fold2LeftStrict");

		/**
		 * Folds a function over the specified list, passing the list index to the folding function.
		 * This is the same as <code>Cal.Collections.List.foldLeftStrict</code>, except for the additional argument in the folding function.
		 * 
		 * <dl><dt><b>See Also:</b>
		 * <dd><b>Functions and Class Methods:</b> Cal.Collections.List.foldLeftStrict
		 * </dl>
		 * 
		 * @param foldFunction (CAL type: <code>a -> b -> Cal.Core.Prelude.Int -> a</code>)
		 *          the function to be used in folding the list.
		 * @param initialValue (CAL type: <code>a</code>)
		 *          the initial value for the folding process.
		 * @param list (CAL type: <code>[b]</code>)
		 *          the list to be folded over.
		 * @return (CAL type: <code>a</code>) 
		 *          the single result obtained from folding <code>foldFunction</code> over the list.
		 */
		public static final SourceModel.Expr foldLeftStrictIndexed(SourceModel.Expr foldFunction, SourceModel.Expr initialValue, SourceModel.Expr list) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.foldLeftStrictIndexed), foldFunction, initialValue, list});
		}

		/**
		 * Name binding for function: foldLeftStrictIndexed.
		 * @see #foldLeftStrictIndexed(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName foldLeftStrictIndexed = 
			QualifiedName.make(
				CAL_CollectionUtilities.MODULE_NAME, 
				"foldLeftStrictIndexed");

		/**
		 * Groups all elements in a list.  The <code>Cal.Collections.List.groupBy</code> function will only
		 * group adjacent items in the list.  Since calculations are not orderable we
		 * can't sort and then call <code>groupBy</code>.  Instead we need a function 
		 * to group all items in a list regardless of whether they are adjacent.
		 * @param eqFunc (CAL type: <code>a -> a -> Cal.Core.Prelude.Boolean</code>)
		 *          used to determine whether two elements belong in the same group.
		 * @param lst (CAL type: <code>[a]</code>)
		 *          the list of elements to be grouped
		 * @return (CAL type: <code>[[a]]</code>) 
		 *          a list of groups of elements.
		 */
		public static final SourceModel.Expr groupAllBy(SourceModel.Expr eqFunc, SourceModel.Expr lst) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.groupAllBy), eqFunc, lst});
		}

		/**
		 * Name binding for function: groupAllBy.
		 * @see #groupAllBy(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName groupAllBy = 
			QualifiedName.make(
				CAL_CollectionUtilities.MODULE_NAME, 
				"groupAllBy");

		/**
		 * Given a list of tuples, group elements by their first components, regardless
		 * of their adjacency in the original list.
		 * <p>
		 * For example, <code>groupByFirst [(1,2), (2,4), (1,5)]</code> yields 
		 * <code>[(1,[2,5]), (2,[4])]</code>.
		 * 
		 * @param eq (CAL type: <code>a -> a -> Cal.Core.Prelude.Boolean</code>)
		 *          used to determine whether two elements belong in the same group.
		 * @param tuples (CAL type: <code>[(a, b)]</code>)
		 *          the list of tuples to be grouped.
		 * @return (CAL type: <code>[(a, [b])]</code>) 
		 *          the list of grouped tuples.
		 */
		public static final SourceModel.Expr groupByFirst(SourceModel.Expr eq, SourceModel.Expr tuples) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.groupByFirst), eq, tuples});
		}

		/**
		 * Name binding for function: groupByFirst.
		 * @see #groupByFirst(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName groupByFirst = 
			QualifiedName.make(
				CAL_CollectionUtilities.MODULE_NAME, 
				"groupByFirst");

		/**
		 * Given a list of tuples, group elements by their first components, regardless
		 * of their adjacency in the original list.
		 * <p>
		 * For example, <code>groupByFirst2 [(1,2), (2,4), (1,5)]</code> yields 
		 * <code>[(1,[2,5]), (2,[4])]</code>.
		 * 
		 * @param eqFunc (CAL type: <code>a -> a -> Cal.Core.Prelude.Boolean</code>)
		 *          used to determine whether two elements belong in the same group.
		 * @param lst (CAL type: <code>[(a, b)]</code>)
		 *          the list of tuples to be grouped.
		 * @return (CAL type: <code>[(a, [b])]</code>) 
		 *          the list of grouped tuples.
		 */
		public static final SourceModel.Expr groupByFirst2(SourceModel.Expr eqFunc, SourceModel.Expr lst) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.groupByFirst2), eqFunc, lst});
		}

		/**
		 * Name binding for function: groupByFirst2.
		 * @see #groupByFirst2(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName groupByFirst2 = 
			QualifiedName.make(
				CAL_CollectionUtilities.MODULE_NAME, 
				"groupByFirst2");

		/**
		 * Given a list of tuples, group elements by their second components, regardless
		 * of their adjacency in the original list.
		 * <p>
		 * For example, <code>groupBySecond [(2,1), (4,2), (5,1)]</code> yields 
		 * <code>[([2,5], 1), ([4],2)]</code>.
		 * 
		 * @param eq (CAL type: <code>b -> b -> Cal.Core.Prelude.Boolean</code>)
		 *          used to determine whether two elements belong in the same group.
		 * @param tuples (CAL type: <code>[(a, b)]</code>)
		 *          the list of tuples to be grouped.
		 * @return (CAL type: <code>[([a], b)]</code>) 
		 *          the list of grouped tuples.
		 */
		public static final SourceModel.Expr groupBySecond(SourceModel.Expr eq, SourceModel.Expr tuples) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.groupBySecond), eq, tuples});
		}

		/**
		 * Name binding for function: groupBySecond.
		 * @see #groupBySecond(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName groupBySecond = 
			QualifiedName.make(
				CAL_CollectionUtilities.MODULE_NAME, 
				"groupBySecond");

		/**
		 * Given a list of tuples, group elements by their second components, regardless
		 * of their adjacency in the original list.
		 * <p>
		 * For example, <code>groupBySecond2 [(2,1), (4,2), (5,1)]</code> yields 
		 * <code>[([2,5], 1), ([4],2)]</code>.
		 * 
		 * @param eqFunc (CAL type: <code>b -> b -> Cal.Core.Prelude.Boolean</code>)
		 *          used to determine whether two elements belong in the same group.
		 * @param lst (CAL type: <code>[(a, b)]</code>)
		 *          the list of tuples to be grouped.
		 * @return (CAL type: <code>[([a], b)]</code>) 
		 *          the list of grouped tuples.
		 */
		public static final SourceModel.Expr groupBySecond2(SourceModel.Expr eqFunc, SourceModel.Expr lst) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.groupBySecond2), eqFunc, lst});
		}

		/**
		 * Name binding for function: groupBySecond2.
		 * @see #groupBySecond2(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName groupBySecond2 = 
			QualifiedName.make(
				CAL_CollectionUtilities.MODULE_NAME, 
				"groupBySecond2");

		/**
		 * Insert each element in a list into a set.
		 * @param valueList (CAL type: <code>Cal.Core.Prelude.Ord a => [a]</code>)
		 *          the elements to insert.
		 * @param set (CAL type: <code>Cal.Core.Prelude.Ord a => Cal.Collections.Set.Set a</code>)
		 *          the set into which to insert the elements.
		 * @return (CAL type: <code>Cal.Core.Prelude.Ord a => Cal.Collections.Set.Set a</code>) 
		 *          a new set containing all elements of the list, in addition to the
		 * contents of the original set.
		 */
		public static final SourceModel.Expr insertListIntoSet(SourceModel.Expr valueList, SourceModel.Expr set) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.insertListIntoSet), valueList, set});
		}

		/**
		 * Name binding for function: insertListIntoSet.
		 * @see #insertListIntoSet(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName insertListIntoSet = 
			QualifiedName.make(
				CAL_CollectionUtilities.MODULE_NAME, 
				"insertListIntoSet");

		/**
		 * Transforms each element of a list into an appendable value, intersperses a
		 * constant separator between them, and then concatenates them.
		 * @param mapFn (CAL type: <code>Cal.Core.Prelude.Appendable b => a -> b</code>)
		 *          a transformation function that makes each list element appendable.
		 * @param separator (CAL type: <code>Cal.Core.Prelude.Appendable b => b</code>)
		 *          a separator to be inserted between each pair of list elements.
		 * @param lst (CAL type: <code>[a]</code>)
		 *          the list to be transformed and joined.
		 * @return (CAL type: <code>Cal.Core.Prelude.Appendable b => b</code>) 
		 *          the transformed and joined list.
		 */
		public static final SourceModel.Expr joinMap(SourceModel.Expr mapFn, SourceModel.Expr separator, SourceModel.Expr lst) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.joinMap), mapFn, separator, lst});
		}

		/**
		 * Name binding for function: joinMap.
		 * @see #joinMap(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName joinMap = 
			QualifiedName.make(CAL_CollectionUtilities.MODULE_NAME, "joinMap");

		/**
		 * Given a function and a domain, returns the inverse of the function over the
		 * image of the domain.  If two values in the domain have the same image, then
		 * either one may be returned by the inverse (i.e. behaviour unspecified).
		 * @param func (CAL type: <code>Cal.Core.Prelude.Ord b => a -> b</code>)
		 *          the function to invert.
		 * @param domain (CAL type: <code>[a]</code>)
		 *          the domain over which to evaluate the function.
		 * @param arg_3 (CAL type: <code>Cal.Core.Prelude.Ord b => b</code>)
		 * @return (CAL type: <code>Cal.Core.Prelude.Maybe a</code>) 
		 *          the inverse of the function - returns <code>Cal.Core.Prelude.Just x</code> if the
		 * argument is <code>x</code>'s image for some <code>x</code> in the domain and 
		 * <code>Cal.Core.Prelude.Nothing</code> otherwise.
		 */
		public static final SourceModel.Expr makeInverse(SourceModel.Expr func, SourceModel.Expr domain, SourceModel.Expr arg_3) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.makeInverse), func, domain, arg_3});
		}

		/**
		 * Name binding for function: makeInverse.
		 * @see #makeInverse(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName makeInverse = 
			QualifiedName.make(
				CAL_CollectionUtilities.MODULE_NAME, 
				"makeInverse");

		/**
		 * Apply a transformation function to each value in a <code>Cal.Collections.Map.Map</code>.
		 * If the function returns <code>Cal.Core.Prelude.Nothing</code> for some map entry, then remove that 
		 * entry.
		 * @param mapFunction (CAL type: <code>a -> Cal.Core.Prelude.Maybe b</code>)
		 *          the transformation function.
		 * @param map (CAL type: <code>Cal.Collections.Map.Map k a</code>)
		 *          the map to transform.
		 * @return (CAL type: <code>Cal.Collections.Map.Map k b</code>) 
		 *          the transformed map.
		 */
		public static final SourceModel.Expr mapJustOverMap(SourceModel.Expr mapFunction, SourceModel.Expr map) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.mapJustOverMap), mapFunction, map});
		}

		/**
		 * Name binding for function: mapJustOverMap.
		 * @see #mapJustOverMap(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName mapJustOverMap = 
			QualifiedName.make(
				CAL_CollectionUtilities.MODULE_NAME, 
				"mapJustOverMap");

		/**
		 * Randomly reorders the elements of a list.
		 * @param lst (CAL type: <code>[a]</code>)
		 *          the list to reorder.
		 * @return (CAL type: <code>[a]</code>) 
		 *          a random reordering of the list.
		 */
		public static final SourceModel.Expr randomizeListOrder(SourceModel.Expr lst) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.randomizeListOrder), lst});
		}

		/**
		 * Name binding for function: randomizeListOrder.
		 * @see #randomizeListOrder(org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName randomizeListOrder = 
			QualifiedName.make(
				CAL_CollectionUtilities.MODULE_NAME, 
				"randomizeListOrder");

		/**
		 * Removes the specified string from the beginning of another string if it is
		 * a prefix and does nothing otherwise.
		 * @param str (CAL type: <code>Cal.Core.Prelude.String</code>)
		 *          the string to have its prefix removed.
		 * @param prefix (CAL type: <code>Cal.Core.Prelude.String</code>)
		 *          the string to remove, if it is a prefix.
		 * @return (CAL type: <code>Cal.Core.Prelude.String</code>) 
		 *          the string with the prefix removed, if it was a valid prefix, and
		 * the original string, otherwise.
		 */
		public static final SourceModel.Expr removePrefix(SourceModel.Expr str, SourceModel.Expr prefix) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.removePrefix), str, prefix});
		}

		/**
		 * @see #removePrefix(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 * @param str
		 * @param prefix
		 * @return the SourceModel.Expr representing an application of removePrefix
		 */
		public static final SourceModel.Expr removePrefix(java.lang.String str, java.lang.String prefix) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.removePrefix), SourceModel.Expr.makeStringValue(str), SourceModel.Expr.makeStringValue(prefix)});
		}

		/**
		 * Name binding for function: removePrefix.
		 * @see #removePrefix(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName removePrefix = 
			QualifiedName.make(
				CAL_CollectionUtilities.MODULE_NAME, 
				"removePrefix");

		/**
		 * Returns a portion of the argument list as a new list.
		 * <p>
		 * If <code>fromIndex &lt; 0</code>, <code>fromIndex &gt; toIndex</code>, or <code>toIndex &gt; length list</code>, the function
		 * terminates returns the empty list.
		 * 
		 * 
		 * <dl><dt><b>See Also:</b>
		 * <dd><b>Functions and Class Methods:</b> Cal.Collections.List.subList
		 * </dl>
		 * 
		 * @param list (CAL type: <code>[a]</code>)
		 *          to extract a sub-list from
		 * @param fromIndex (CAL type: <code>Cal.Core.Prelude.Int</code>)
		 *          inclusive 0-based index.
		 * @param toIndex (CAL type: <code>Cal.Core.Prelude.Int</code>)
		 *          exclusive 0-based index
		 * @return (CAL type: <code>[a]</code>) 
		 *          copy of the list from <code>fromIndex</code> (inclusive) to <code>toIndex</code> (exclusive).
		 */
		public static final SourceModel.Expr subListSafe(SourceModel.Expr list, SourceModel.Expr fromIndex, SourceModel.Expr toIndex) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.subListSafe), list, fromIndex, toIndex});
		}

		/**
		 * @see #subListSafe(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 * @param list
		 * @param fromIndex
		 * @param toIndex
		 * @return the SourceModel.Expr representing an application of subListSafe
		 */
		public static final SourceModel.Expr subListSafe(SourceModel.Expr list, int fromIndex, int toIndex) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.subListSafe), list, SourceModel.Expr.makeIntValue(fromIndex), SourceModel.Expr.makeIntValue(toIndex)});
		}

		/**
		 * Name binding for function: subListSafe.
		 * @see #subListSafe(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName subListSafe = 
			QualifiedName.make(
				CAL_CollectionUtilities.MODULE_NAME, 
				"subListSafe");

		/**
		 * Replaces items at the specified indices.
		 * @param lst (CAL type: <code>Cal.Core.Prelude.Typeable a => Cal.Collections.Array.Array a</code>)
		 *          the list to modify.
		 * @param replacementIndices (CAL type: <code>[Cal.Core.Prelude.Int]</code>)
		 *          the indices of elements to modify.  The elements must
		 * be distinct, valid indices.
		 * @param replacementValues (CAL type: <code>Cal.Core.Prelude.Typeable a => [a]</code>)
		 *          the values with which to replace the list elements at
		 * the corresponding indices.  Must be the same length as replacementIndices.
		 * @return (CAL type: <code>Cal.Core.Prelude.Typeable a => Cal.Collections.Array.Array a</code>) 
		 *          the modified list.
		 */
		public static final SourceModel.Expr substituteArrayValues(SourceModel.Expr lst, SourceModel.Expr replacementIndices, SourceModel.Expr replacementValues) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.substituteArrayValues), lst, replacementIndices, replacementValues});
		}

		/**
		 * Name binding for function: substituteArrayValues.
		 * @see #substituteArrayValues(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName substituteArrayValues = 
			QualifiedName.make(
				CAL_CollectionUtilities.MODULE_NAME, 
				"substituteArrayValues");

		/**
		 * Replaces items at the specified indices.
		 * @param lst (CAL type: <code>[a]</code>)
		 *          the list to modify.
		 * @param replacementIndices (CAL type: <code>[Cal.Core.Prelude.Int]</code>)
		 *          the indices of elements to modify.  The elements must
		 * be distinct, valid indices.
		 * @param replacementValues (CAL type: <code>[a]</code>)
		 *          the values with which to replace the list elements at
		 * the corresponding indices.  Must be the same length as replacementIndices.
		 * @return (CAL type: <code>[a]</code>) 
		 *          the modified list.
		 */
		public static final SourceModel.Expr substituteListValues(SourceModel.Expr lst, SourceModel.Expr replacementIndices, SourceModel.Expr replacementValues) {
			return 
				SourceModel.Expr.Application.make(
					new SourceModel.Expr[] {SourceModel.Expr.Var.make(Functions.substituteListValues), lst, replacementIndices, replacementValues});
		}

		/**
		 * Name binding for function: substituteListValues.
		 * @see #substituteListValues(org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr, org.openquark.cal.compiler.SourceModel.Expr)
		 */
		public static final QualifiedName substituteListValues = 
			QualifiedName.make(
				CAL_CollectionUtilities.MODULE_NAME, 
				"substituteListValues");

		/**
		 * A convenience constant for representing an uninitialized value of any type.
		 * Will throw an error if it is evaluated.
		 * @return (CAL type: <code>a</code>) 
		 *          an uninitialized value of any type.
		 */
		public static final SourceModel.Expr uninitializedValue() {
			return SourceModel.Expr.Var.make(Functions.uninitializedValue);
		}

		/**
		 * Name binding for function: uninitializedValue.
		 * @see #uninitializedValue()
		 */
		public static final QualifiedName uninitializedValue = 
			QualifiedName.make(
				CAL_CollectionUtilities.MODULE_NAME, 
				"uninitializedValue");

	}
	/**
	 * A hash of the concatenated JavaDoc for this class (including inner classes).
	 * This value is used when checking for changes to generated binding classes.
	 */
	public static final int javaDocHash = -697892984;

}
